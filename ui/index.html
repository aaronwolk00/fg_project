<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FG Pro UI v4 — Part 1/6 (Shell)</title>
  <!-- Tailwind CDN (no build step) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    /* Tailwind design tokens */
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            brand: {
              50:  '#eff6ff',
              100: '#dbeafe',
              200: '#bfdbfe',
              300: '#93c5fd',
              400: '#60a5fa',
              500: '#3b82f6', // primary
              600: '#2563eb',
              700: '#1d4ed8',
              800: '#1e40af',
              900: '#1e3a8a'
            },
            ink: {
              50:'#f8fafc',100:'#f1f5f9',200:'#e2e8f0',300:'#cbd5e1',400:'#94a3b8',500:'#64748b',
              600:'#475569',700:'#334155',800:'#1f2937',900:'#0f172a'
            },
          },
          boxShadow: {
            soft: '0 1px 2px rgba(0,0,0,0.06), 0 1px 1px rgba(0,0,0,0.04)'
          }
        }
      }
    };
  </script>
  <style>
    /* Define color variables (ensure your body classes reference these) */
    :root {
      --card: #ffffff;
      --card-border: #e5e7eb;
      /* NOTE: You need to define the 'brand' and 'ink' colors used by the Tailwind classes
         (e.g., brand-600, ink-700) for the color properties below to work correctly.
         I am using placeholders for these custom colors. */
      --brand-600: #1d4ed8; /* Placeholder for a blue color */
      --brand-700: #1e40af; /* Placeholder for a darker blue */
      --brand-50: #eff6ff;  /* Placeholder for a light blue */
      --brand-200: #bfdbfe; /* Placeholder for a medium blue */
      --ink-700: #374151;  /* Placeholder for a dark gray text */
      --ink-100: #f3f4f6;  /* Placeholder for a light gray hover */
      --ink-600: #4b5563;  /* Placeholder for a muted gray label */
      --ink-200: #e5e7eb;  /* Placeholder for a border gray */
      --ink-900: #111827;  /* Placeholder for body text */
      --ink-50: #f9fafb;   /* Placeholder for body background */
    }

    /* Simple utility aliases (mini design system) */
    body { color: var(--ink-900); background-color: var(--ink-50); }

    .card { 
      background: var(--card); 
      border: 1px solid var(--card-border); 
      border-radius: 0.75rem; 
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.04); 
    } 
    .card-pad { padding: 1rem; }

    .btn { 
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      border-radius: 0.75rem;
      padding: 0.5rem 0.75rem;
      font-size: 0.875rem;
      font-weight: 500;
      /* transition and active:scale-[] properties are complex to emulate purely in CSS */
      transition: all 0.1s ease;
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); 
    }

    .btn-primary { 
      background-color: var(--brand-600); 
      color: white; 
    }
    .btn-primary:hover { 
      background-color: var(--brand-700); 
    }

    .btn-ghost { 
      color: var(--ink-700); 
    }
    .btn-ghost:hover { 
      background-color: var(--ink-100); 
    }

    .seg { 
      display: inline-flex; 
      border-radius: 0.75rem; 
      border: 1px solid var(--ink-200); 
      overflow: hidden; 
    }
    .seg button { 
      padding: 0.375rem 0.75rem; 
      font-size: 0.875rem; 
    }
    .seg .on { 
      background-color: var(--brand-50); 
      color: var(--brand-700); 
      border: 1px solid var(--brand-200); 
    }
    .seg .off { 
      color: var(--ink-700); 
    }
    .seg .off:hover { 
      background-color: var(--ink-100); 
    }

    .pill { 
      display: inline-flex; 
      align-items: center; 
      gap: 0.5rem; 
      border-radius: 9999px; /* full */
      padding: 0.25rem 0.75rem; 
      font-size: 0.75rem; /* xs */
      font-weight: 500; 
      border: 1px solid var(--ink-200); 
      background-color: white; 
    }

    .label { 
      font-size: 0.75rem; 
      font-weight: 600; 
      letter-spacing: 0.05em; /* tracking-wide */
      color: var(--ink-600); 
    }

    .input { 
      width: 100%; 
      border-radius: 0.5rem; 
      border: 1px solid var(--ink-200); 
      background-color: white; 
      padding: 0.5rem 0.75rem; 
      font-size: 0.875rem; 
      outline: none; 
      /* focus:ring-2 focus:ring-brand-300 is complex; use a simple focus border: */
    }
    .input:focus {
      border-color: var(--brand-600);
    }
    
    .tab-btn { 
      padding: 0.5rem 1rem; 
      font-size: 0.875rem; 
      font-weight: 500; 
      border-radius: 0.5rem; 
    }
    .tab-btn:hover { 
      background-color: var(--ink-100); 
    }
    
    .tab-btn[aria-selected="true"] { 
      background-color: var(--brand-600); 
      color: white; 
    }
    .tab-btn[aria-selected="true"]:hover { 
      background-color: var(--brand-600); 
    }
</style>
</head>
<body class="min-h-screen bg-ink-50 text-ink-900">
    <header class="sticky top-0 z-40 bg-white border-b border-ink-200">
      <div class="max-w-[1280px] mx-auto px-4 sm:px-6 lg:px-8 py-3 flex items-center gap-3">
        <div class="flex items-center gap-2">
          <span class="inline-flex h-8 w-8 items-center justify-center rounded-lg bg-brand-600 text-white font-bold">FG</span>
          <h1 class="text-base sm:text-lg font-semibold">FG Pro UI v4</h1>
        </div>

        <div class="flex-1"></div>

      <!-- Team / Kicker selectors -->
      <div class="flex items-center gap-3">
        <div class="hidden sm:flex flex-col">
          <label for="teamSelect" class="label">Team</label>
          <select id="teamSelect" class="input min-w-[9rem]" aria-label="Select Team">
            <option value="">— select —</option>
          </select>
        </div>
        <div class="hidden sm:flex flex-col">
          <label for="kickerSelect" class="label">Kicker <span class="text-ink-400">(starter in parentheses)</span></label>
          <select id="kickerSelect" class="input min-w-[12rem]" aria-label="Select Kicker" disabled>
            <option value="">— select team first —</option>
          </select>
        </div>
        <!-- Environment quick toggles -->
        <div class="hidden lg:flex flex-col">
          <span class="label">Environment</span>
          <div class="seg" role="tablist" aria-label="Environment">
            <button id="envIndoor" class="on" data-env="indoor" aria-pressed="true">Indoor</button>
            <button id="envOutdoor" class="off" data-env="outdoor" aria-pressed="false">Outdoor</button>
          </div>
        </div>
        <div class="hidden lg:flex flex-col">
          <span class="label">Altitude</span>
          <div class="seg" role="tablist" aria-label="Altitude">
            <button class="on" data-alt="sea">Sea</button>
            <button class="off" data-alt="mid">Mid</button>
            <button class="off" data-alt="high">High</button>
          </div>
        </div>
      </div>
    </div>
  </header>

  <!-- Main layout -->
  <main class="max-w-[1280px] mx-auto px-4 sm:px-6 lg:px-8 py-4 grid grid-cols-1 lg:grid-cols-12 gap-4">
    <!-- Left controls -->
    <aside class="lg:col-span-4 space-y-4">
      <!-- LEFT-RAIL: Team & Kicker selectors (place above Scenario card) -->
<section class="card card-pad" id="teamKickerCard">
  <h2 class="text-sm font-semibold mb-3">Team & Kicker</h2>
  <div class="grid grid-cols-1 gap-3">
    <div>
      <label class="label" for="teamSelectLR">Team</label>
      <select id="teamSelectLR" class="input" aria-label="Select Team (Left)">
        <option value="">— select —</option>
      </select>
    </div>
    <div>
      <label class="label" for="kickerSelectLR">Kicker <span class="text-ink-400">(starter in parentheses)</span></label>
      <select id="kickerSelectLR" class="input" aria-label="Select Kicker (Left)" disabled>
        <option value="">— select team first —</option>
      </select>
      <p class="text-[11px] mt-1 text-ink-500">Inactive kickers are grayed out.</p>
    </div>
    <div class="mt-3">
      <label class="label" for="stadiumSelectLR">Stadium</label>
      <select id="stadiumSelectLR" class="input" aria-label="Select Stadium (Left)" disabled>
        <option value="">— select team first —</option>
      </select>
      <p class="text-[11px] mt-1 text-ink-500">Selecting a venue sets indoor/outdoor and altitude automatically.</p>
    </div>
  </div>
</section>

<section class="card card-pad" id="advancedCtxCard">
  <h2 class="text-sm font-semibold mb-3">Advanced Context</h2>
  <div class="grid grid-cols-2 gap-3">
    <div>
      <label class="label" for="downSel">Down</label>
      <select id="downSel" class="input">
        <option value="1">1st</option>
        <option value="2">2nd</option>
        <option value="3">3rd</option>
        <option value="4" selected>4th</option>
      </select>
    </div>
    <div>
      <label class="label" for="ytgExact">Yards to go</label>
      <input id="ytgExact" class="input" type="number" min="0" max="40" step="1" value="5">
    </div>
    <div>
      <label class="label" for="timeMMSS">Time remaining (mm:ss)</label>
      <input id="timeMMSS" class="input" type="text" placeholder="07:30">
    </div>
    <div>
      <label class="label" for="scoreDiffExact">Score diff (off − def)</label>
      <input id="scoreDiffExact" class="input" type="number" step="1" value="0">
    </div>
    <div>
      <label class="label" for="toOff">Timeouts (off)</label>
      <input id="toOff" class="input" type="number" min="0" max="3" value="3">
    </div>
    <div>
      <label class="label" for="toDef">Timeouts (def)</label>
      <input id="toDef" class="input" type="number" min="0" max="3" value="3">
    </div>
  </div>
  <p class="text-[11px] mt-2 text-ink-500">Exact inputs override bins for decisions; Attempt% still uses nearest bins.</p>
</section>

<!-- OPTIONAL: Wind direction segmented (place under Context or Scenario if desired) -->
<section class="card card-pad" id="windDirCard">
  <h2 class="text-sm font-semibold mb-3">Wind Direction</h2>
  <div class="seg" role="tablist" aria-label="Wind Direction">
    <button class="on"   data-dir="calm"   aria-pressed="true">Calm</button>
    <button class="off"  data-dir="head">Head</button>
    <button class="off"  data-dir="tail">Tail</button>
    <button class="off"  data-dir="crossL">Cross ⟵</button>
    <button class="off"  data-dir="crossR">Cross ⟶</button>
  </div>
</section>
      <!-- Query controls -->
      <section class="card card-pad">
        <h2 class="text-sm font-semibold mb-3">Scenario</h2>
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
          <div>
            <label class="label" for="distance">Distance (yd)</label>
            <input id="distance" type="range" min="18" max="68" value="45" class="w-full" />
            <div class="text-xs text-ink-600 mt-1"><span id="distanceVal">45</span> yds</div>
          </div>
          <div>
            <label class="label" for="temp">Temp (°F)</label>
            <input id="temp" type="range" min="0" max="110" value="60" class="w-full" />
            <div class="text-xs text-ink-600 mt-1"><span id="tempVal">60</span> °F</div>
          </div>
          <div>
            <label class="label" for="wind">Wind (mph)</label>
            <input id="wind" type="range" min="0" max="25" value="5" class="w-full" />
            <div class="text-xs text-ink-600 mt-1"><span id="windVal">5</span> mph</div>
          </div>
          <div class="flex items-end gap-2">
            <button class="btn btn-ghost" id="resetBtn">Reset</button>
            <button class="btn btn-primary" id="applyBtn">Apply</button>
          </div>
        </div>
      </section>

    </aside>

    <!-- Right content -->
    <section class="lg:col-span-8 space-y-3">
      <!-- Tabs -->
      <div class="flex items-center gap-2">
        <button class="tab-btn" role="tab" aria-selected="false" data-tab="decisionTab">Decision Edge</button>
        <button class="tab-btn" role="tab" aria-selected="true" data-tab="makeTab">Make%</button>
        <button class="tab-btn" role="tab" aria-selected="false" data-tab="attemptTab">Attempt%</button>
      </div>

      <!-- Panels -->
      <div class="card card-pad hidden" id="decisionTab" role="tabpanel">
        <div id="decisionChart" class="h-[380px] w-full bg-ink-100/60 rounded-lg border border-ink-200 flex items-center justify-center text-ink-500">
          <span class="text-sm">Decision Edge chart stub</span>
        </div>
      </div>
      <div class="card card-pad" id="makeTab" role="tabpanel">
        <div id="makeChart" class="h-[380px] w-full bg-ink-100/60 rounded-lg border border-ink-200 flex items-center justify-center text-ink-500">
          <span class="text-sm">Make% chart stub</span>
        </div>
      </div>

      <div class="card card-pad hidden" id="attemptTab" role="tabpanel">
        <div id="attemptChart" class="h-[380px] w-full bg-ink-100/60 rounded-lg border border-ink-200 flex items-center justify-center text-ink-500">
          <span class="text-sm">Attempt% chart stub</span>
        </div>
      </div>

    </section>
  </main>

  <!-- Vanilla JS: lightweight state + stubs -->
  <script>
    const state = {
      team: '',
      kicker: '',
      env: 'indoor',
      alt: 'sea',
      distance: 45,
      tempF: 60,
      wind: 5,
      scoreBin: 'close',
      timeBin: 'mid',
      ytgBin: 'med',
      // versions (populated when JSONs load)
      versions: { data: '—', schema: '—' }
    };

    // --- Element refs
    const teamSelect   = document.getElementById('teamSelect');
    const kickerSelect = document.getElementById('kickerSelect');
    const envIndoorBtn = document.getElementById('envIndoor');
    const envOutdoorBtn= document.getElementById('envOutdoor');

    const distance = document.getElementById('distance');
    const temp     = document.getElementById('temp');
    const wind     = document.getElementById('wind');
    const distanceVal = document.getElementById('distanceVal');
    const tempVal     = document.getElementById('tempVal');
    const windVal     = document.getElementById('windVal');

    const scoreBin = document.getElementById('scoreBin');
    const timeBin  = document.getElementById('timeBin');
    const ytgBin   = document.getElementById('ytgBin');

    const statusText    = document.getElementById('statusText');
    const dataVersionEl = document.getElementById('dataVersion');
    const schemaVersionEl = document.getElementById('schemaVersion');

    // --- Placeholder data loaders (wired in later parts)
    async function loadRoster(){
      // Expect ./nfl_kicker_roster.json (written by pipeline) — graceful fallback
      try{
        const res = await fetch('./nfl_kicker_roster.json', {cache:'no-store'});
        if(!res.ok) throw new Error('not found');
        return await res.json();
      }catch(e){
        console.warn('Roster not found yet. Using minimal sample.');
        return [
          { team:'BAL', kickers:[{id:'k1', name:'Justin Tucker', starter:true},{id:'k2', name:'Practice K', starter:false}]},
          { team:'KC',  kickers:[{id:'k3', name:'Harrison Butker', starter:true}]}
        ];
      }
    }

    function populateTeamAndKicker(roster){
      // Teams
      const teams = roster.map(r=>r.team);
      for(const t of teams){
        const opt = document.createElement('option');
        opt.value = t; opt.textContent = t; teamSelect.appendChild(opt);
      }
      // Team change → fill kicker list, show starter in parentheses in the label
      teamSelect.addEventListener('change', () => {
        state.team = teamSelect.value;
        // wipe kickers
        kickerSelect.innerHTML = '';
        const entry = roster.find(r=>r.team===state.team);
        if(!entry){ kickerSelect.disabled = true; return; }
        kickerSelect.disabled = false;
        const starter = entry.kickers.find(k=>k.starter);
        // Build options
        for(const k of entry.kickers){
          const opt = document.createElement('option');
          opt.value = k.id;
          opt.textContent = k.name + (starter && k.id===starter.id ? ' (starter)' : '');
          kickerSelect.appendChild(opt);
        }
        kickerSelect.value = starter ? starter.id : entry.kickers[0]?.id || '';
        state.kicker = kickerSelect.value;
      });
      kickerSelect.addEventListener('change', ()=>{ state.kicker = kickerSelect.value; });
    }

    // --- Environment segmented control
    function setEnv(which){
      which = window.FG?.norm?.env(which);
      // update state + emit
      window.state = window.state || {};
      window.state.env = which;
      window.dispatchEvent(new CustomEvent('fg:stateChanged', { detail: { ...window.state } }));
      // reflect buttons
      envIndoorBtn.classList.toggle('on', which==='indoor');
      envIndoorBtn.classList.toggle('off', which!=='indoor');
      envIndoorBtn.setAttribute('aria-pressed', String(which==='indoor'));
      envOutdoorBtn.classList.toggle('on', which==='outdoor');
      envOutdoorBtn.classList.toggle('off', which!=='outdoor');
      envOutdoorBtn.setAttribute('aria-pressed', String(which==='outdoor'));
    }
    envIndoorBtn.addEventListener('click', ()=>setEnv('indoor'));
    envOutdoorBtn.addEventListener('click', ()=>setEnv('outdoor'));

    // --- Sliders → labels
    const sync = () => {
      distanceVal.textContent = state.distance = +distance.value;
      tempVal.textContent = state.tempF = +temp.value;
      windVal.textContent = state.wind = +wind.value;
    };
    [distance,temp,wind].forEach(el=>el.addEventListener('input', sync));
    sync();

    // --- Context selects
    scoreBin.addEventListener('change', ()=>state.scoreBin=scoreBin.value);
    timeBin.addEventListener('change', ()=>state.timeBin=timeBin.value);
    ytgBin.addEventListener('change', ()=>state.ytgBin=ytgBin.value);

    // --- Tabs
    const tabButtons = [...document.querySelectorAll('.tab-btn')];
    const panels = {
      makeTab: document.getElementById('makeTab'),
      attemptTab: document.getElementById('attemptTab'),
      decisionTab: document.getElementById('decisionTab')
    };
    function switchTab(id){
      for(const btn of tabButtons){ btn.setAttribute('aria-selected', String(btn.dataset.tab===id)); }
      for(const [pid, el] of Object.entries(panels)){
        el.classList.toggle('hidden', pid!==id);
      }
    }
    tabButtons.forEach(btn=>btn.addEventListener('click', ()=>switchTab(btn.dataset.tab)));

    // --- Footer status helpers
    function setStatus(msg){ statusText.textContent = msg; }
    function setVersions(dataV, schemaV){
      state.versions.data = dataV; state.versions.schema = schemaV;
      dataVersionEl.textContent = dataV; schemaVersionEl.textContent = schemaV;
    }

    // --- Apply/Reset hooks (wire to models in later parts)
    document.getElementById('applyBtn').addEventListener('click', ()=>{
      setStatus('Applied scenario. (Charts will render when data loads in Parts 2–6)');
    });
    document.getElementById('resetBtn').addEventListener('click', ()=>{
      distance.value = 45; temp.value = 60; wind.value = 5; sync(); setEnv('indoor');
      scoreBin.value='close'; timeBin.value='mid'; ytgBin.value='med';
      setStatus('Reset to defaults.');
    });

    // --- Bootstrap
    (async function init(){
      setEnv('indoor');
      try{
        const ds = window.FG?.DataStore;
        if(!(ds && ds.getTeams)){
          const roster = await loadRoster();
          populateTeamAndKicker(roster);
        }
      }catch{}
      // Versions (try to read manifest if present)
      try{
        const man = await fetch('./manifest.json', {cache:'no-store'}).then(r=>r.ok?r.json():null);
        if(man){ setVersions(man.generated_at_epoch ? new Date(man.generated_at_epoch*1000).toISOString() : 'manifest', 'v4'); }
        else { setVersions('local', 'v4'); }
      }catch{ setVersions('local', 'v4'); }
      setStatus('Ready');
    })();
  </script>

<script id="fg-core">
  (function(){
    // Namespace
    window.FG = window.FG || {};
    const FG = window.FG;
  
    // ---------- Single-init “ready” to prevent DataStore races ----------
    FG.ready = function(){
      if (FG._ready) return FG._ready;
      FG._ready = (async ()=> {
        if (!FG.DataStore && FG.DataStoreClass?.init){
          FG.DataStore = await FG.DataStoreClass.init({ baseUrl: '.' });
        }
        return FG.DataStore;
      })();
      return FG._ready;
    };
  
    // ---------- Keyed listener binder (de-dupes) ----------
    const _bound = new WeakMap();
    FG.on = function(el, type, handler, key, opts){
      if(!el || !type || !handler) return;
      let map = _bound.get(el);
      if(!map){ map = new Map(); _bound.set(el, map); }
      const sig = type + '::' + String(key || handler);
      if(map.has(sig)) return; // already attached
      el.addEventListener(type, handler, opts || false);
      map.set(sig, { handler, opts: (opts || false) });
    };
  
    // ---------- Coalesced state emitter (avoids event storms) ----------
    let _pending = false, _last = null;
    FG.emitState = function(detail){
      _last = detail || { ...(window.state || {}) };
      if(_pending) return;
      _pending = true;
      requestAnimationFrame(()=>{
        window.dispatchEvent(new CustomEvent('fg:stateChanged', { detail:_last }));
        _pending = false;
      });
    };
  
    // ---------- Normalizers (fix string compare edge-cases) ----------
    FG.norm = {
      team: t => String(t||'').trim().toUpperCase(),
      env:  v => (String(v||'').toLowerCase()==='outdoor' ? 'outdoor' : 'indoor'),
      windDir(v){
        const ok = { calm:1, head:1, tail:1, crossL:1, crossR:1 };
        const s = String(v||'').trim();
        return ok[s] ? s : 'calm';
      },
      bool: v => (v===true) || (String(v).toLowerCase()==='true')
    };
  
    // ---------- Abortable fetch to prevent overlapping results ----------
    const _inflight = new Map();
    FG.fetchJson = async function(url, key=url){
      try{
        const prev = _inflight.get(key);
        if(prev){ prev.abort.abort(); }
        const abort = new AbortController();
        _inflight.set(key, { abort });
        const res = await fetch(url, { cache:'no-store', signal: abort.signal });
        _inflight.delete(key);
        if(!res.ok) throw new Error(res.status+':'+res.statusText);
        return await res.json();
      }catch(err){
        if(err?.name === 'AbortError') return { __aborted:true };
        return { __missing:true, __error:String(err), __url:url };
      }
    };
  
    // ---------- Mount guard for components (prevents double mount) ----------
    FG.mountOnce = function(host, key){
      if(!host) return false;
      const k = 'fgMount_' + key;
      if(host.dataset[k] === '1') return false;
      host.dataset[k] = '1';
      return true;
    };
  })();
  </script>
  

  <!-- Paste this <script> block near the end of index.html, before the closing </body> -->
<script>
  /*
    FG Pro UI v4 — Part 2/6 (Data Loader & Schema v2)
    - Fetches required JSONs
    - Detects schema_version (v1/v2) and adapts
    - Exposes window.FG.DataStore with getters
    - Non-blocking diagnostics toast if files are missing
  
    Usage example after init():
      const ds = await FG.DataStore.init({ baseUrl: '.' });
      const pMake = ds.getMakeProb({ env: 'outdoor', distance: 55, temp_F: 60, wind_mph: 8 });
      const roster = ds.getRoster();
  */
  (function(){
    // ------------------- Toast/diagnostics helpers -------------------
    const Toast = {
      ensureHost(){
        let host = document.getElementById('fg_toasts');
        if(!host){
          host = document.createElement('div');
          host.id = 'fg_toasts';
          host.style.position = 'fixed';
          host.style.right = '12px';
          host.style.bottom = '12px';
          host.style.zIndex = 9999;
          host.style.display = 'flex';
          host.style.flexDirection = 'column';
          host.style.gap = '8px';
          document.body.appendChild(host);
        }
        return host;
      },
      show(msg, type='info', timeout=4200){
        const host = this.ensureHost();
        const card = document.createElement('div');
        card.setAttribute('role', 'status');
        card.style.maxWidth = '360px';
        card.style.padding = '10px 12px';
        card.style.borderRadius = '12px';
        card.style.border = '1px solid #e5e7eb';
        card.style.background = type==='error' ? '#fff1f2' : type==='warn' ? '#fff7ed' : '#f8fafc';
        card.style.boxShadow = '0 6px 16px rgba(0,0,0,.08)';
        card.style.font = '12px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
        card.style.color = '#0f172a';
        card.textContent = msg;
        host.appendChild(card);
        if(timeout>0){ setTimeout(()=> card.remove(), timeout); }
        return card;
      }
    };
    window.FG = window.FG || {};
    window.FG.toast = (m,t,ms)=>Toast.show(m,t,ms);
  
    // ------------------- Fetch JSON utility -------------------
    async function fetchJson(url){
      return await (window.FG?.fetchJson?.(url, url)) || { __missing:true, __url:url };
    }
  
    // ------------------- Schema helpers -------------------
    function detectSchema(obj){
      try{
        const v = obj?.meta?.schema_version ?? obj?.schema_version;
        if(typeof v === 'number') return v;
        // Heuristics: v2 if new axes exist on any row
        const row = Array.isArray(obj?.grid) && obj.grid[0] ? obj.grid[0] : null;
        if(row && (('wind_head_mps' in row) || ('wind_cross_mps' in row) || ('altitude_m' in row) || ('air_density_ratio' in row) || ('hash' in row) || ('foot' in row))) return 2;
      }catch(e){ /* noop */ }
      return 1;
    }
    function roundTo(v, step){ return Math.round(+v/step)*step; }
  
    // ------------------- Normalizers -------------------
    function normalizeMakeGrid(raw){
      const schema = detectSchema(raw);
      const grid = Array.isArray(raw?.grid) ? raw.grid : [];
      const rows = grid.map(r=>({
        distance: +r.distance,
        env: (r.indoor_outdoor || r.env || 'indoor'),
        temp_F: (r.temp_F ?? 60),
        wind_mph: (r.wind_mph ?? (r.wind_head_mps!=null? Math.round(r.wind_head_mps/0.44704):0)),
        wind_head_mps: (r.wind_head_mps ?? ((r.wind_mph!=null)? (r.wind_mph*0.44704):0)),
        wind_cross_mps: (r.wind_cross_mps ?? 0),
        altitude_m: (r.altitude_m ?? 0),
        air_density_ratio: (r.air_density_ratio ?? 1),
        prob_mean: +r.prob_mean
      }));
      // Index by env for quick lookup
      const byEnv = { indoor: [], outdoor: [] };
      for(const r of rows){ if(byEnv[r.env]) byEnv[r.env].push(r); }
      return { schema, byEnv };
    }
  
    function normalizeAttemptGrid(raw){
      const schema = detectSchema(raw);
      const grid = Array.isArray(raw?.grid) ? raw.grid : [];
      const rows = grid.map(r=>({
        distance: +r.distance,
        env: (r.indoor_outdoor || r.env || 'indoor'),
        score_bin: r.score_bin || 'close',
        time_bin: r.time_bin || 'mid',
        ytg_bin: r.ytg_bin || 'med',
        hash: r.hash || null,  // v2 option
        prob_attempt_mean: +r.prob_attempt_mean
      }));
      return { schema, rows };
    }
  
    function normalizeKickerDeltas(rawBanded, rawByDist){
      // prefer by-distance if present
      if(rawByDist && !rawByDist.__missing && Array.isArray(rawByDist)){
        const map = new Map();
        for(const k of rawByDist){
          const byD = k.by_distance || {};
          const dist = {}; Object.keys(byD).forEach(d=>{ dist[+d] = byD[d]; });
          map.set(String(k.kicker_id), { name: k.kicker_name, by_distance: dist });
        }
        return { kind: 'by_distance', map };
      }
      // fall back to banded
      const list = Array.isArray(rawBanded) ? rawBanded : [];
      const map = new Map();
      for(const k of list){ map.set(String(k.kicker_id), k); }
      return { kind: 'banded', map };
    }
  
    function bandForDistance(d){
      if(d<=39) return 'short';
      if(d<=49) return 'mid';
      if(d<=59) return 'long';
      return 'xlong';
    }
  
    // ------------------- DataStore -------------------
    class DataStore {

      // Inside class DataStore { ... }

      _applyVenueAdjustments({ stadiumId=null, env='indoor', distance, temp_F=60,
                              wind_mph=0, wind_head_mps=0, wind_cross_mps=0,
                              altitude_m=0 }) {
        // Wind attenuation by roof type
        let windMult = (env === 'indoor') ? 0 : 1;
        try {
          const v = this.getVenueById?.(stadiumId);
          const roof = String(v?.roof_type || '').toLowerCase();
          if (env !== 'indoor') {
            if (roof.includes('retract')) windMult = 0.35;
            if (roof.includes('dome'))    windMult = 0;
          }
        } catch {}

        // apply attenuation
        wind_mph       *= windMult;
        wind_head_mps  *= windMult;
        wind_cross_mps *= windMult;

        // --- NEW: if the grid lacks wind direction, fold direction into distance ---
        // (so headwind lengthens the effective kick; tailwind shortens it; cross ≈ small penalty)
        if (!this.hasDirAxis && (wind_head_mps || wind_cross_mps)) {
          const head_mph  = wind_head_mps / 0.44704;           // + = headwind, - = tailwind
          const cross_mph = Math.abs(wind_cross_mps) / 0.44704;
          const kHead  = 0.18;  // ~+/-0.18 yards per 1 mph head/tail
          const kCross = 0.06;  // ~+0.06 yards per 1 mph cross
          distance = distance + kHead*head_mph + kCross*cross_mph;
        }

        // If no altitude axis, apply carry correction
        if (!this.hasAltAxis && altitude_m) {
          const adr   = Math.exp(-(Number(altitude_m)||0)/8500);
          const carry = Math.pow(adr, -0.5);
          distance = distance / carry;
        }

        return { distance, temp_F, wind_mph, wind_head_mps, wind_cross_mps, altitude_m };
      }

      static async init(opts){
        const base = (opts?.baseUrl || '.').replace(/\/$/, '');
        const files = {
          make:  base + '/fg_prob_grid_distance_env_temp_wind.json',
          attempt: base + '/fg_attempt_grid_distance_env_context.json',
          deltasBanded: base + '/kicker_deltas_logit_banded.json',
          deltasByDist: base + '/kicker_deltas_by_distance.json',
          sens:  base + '/attempt_sensitivity.json',
          roster: base + '/nfl_kicker_roster.json',
          stadiums: '/stadiums.json',
          manifest: base + '/manifest.json'
        };
  
        const [makeJ, attemptJ, bandedJ, byDistJ, sensJ, rosterJ, manifestJ] = await Promise.all([
          fetchJson(files.make), fetchJson(files.attempt), fetchJson(files.deltasBanded), fetchJson(files.deltasByDist),
          fetchJson(files.sens), fetchJson(files.roster), fetchJson(files.manifest)
        ]);
  
        const missing = Object.entries({ makeJ, attemptJ, sensJ }).filter(([,o])=>o.__missing);
        if(missing.length){ Toast.show('Some model files are missing — UI will degrade gracefully. ('+missing.map(([k])=>k.replace('J','')).join(', ')+')','warn',6000); }
        if(rosterJ.__missing){ Toast.show('Roster not found — team/kicker select limited.','warn',4600); }
  
        // normalize
        const make = !makeJ.__missing ? normalizeMakeGrid(makeJ) : { schema:1, byEnv:{indoor:[],outdoor:[]} };
        const attempt = !attemptJ.__missing ? normalizeAttemptGrid(attemptJ) : { schema:1, rows:[] };
        const deltas = normalizeKickerDeltas(bandedJ.__missing?[]:bandedJ, byDistJ.__missing?null:byDistJ);
        const sens = (!sensJ.__missing && sensJ.A!=null && sensJ.B!=null && sensJ.C!=null) ? sensJ : {A:0,B:0,C:1};
        const roster = Array.isArray(rosterJ) ? rosterJ : [];
        const manifest = manifestJ.__missing ? null : manifestJ;
  
        const ds = new DataStore(base, files, make, attempt, deltas, sens, roster, manifest);
        window.FG.DataStore = ds; // expose singleton instance
        return ds;
      }
  
      constructor(base, files, make, attempt, deltas, sens, roster, manifest){
        this.base = base; this.files = files; this._make = make; this._attempt = attempt;
        this._deltas = deltas; this._sens = sens; this._roster = roster; this._manifest = manifest;
        this.hasDirAxis = !!(
          (make.schema >= 2) &&
          (
            (make.byEnv.indoor?.[0] && ('wind_head_mps' in make.byEnv.indoor[0] || 'wind_cross_mps' in make.byEnv.indoor[0])) ||
            (make.byEnv.outdoor?.[0] && ('wind_head_mps' in make.byEnv.outdoor[0] || 'wind_cross_mps' in make.byEnv.outdoor[0]))
          )
        );
        this.hasAltAxis = !!(
          (make.schema >= 2) &&
          (
            (make.byEnv.indoor?.[0] && ('altitude_m' in make.byEnv.indoor[0])) ||
            (make.byEnv.outdoor?.[0] && ('altitude_m' in make.byEnv.outdoor[0]))
          )
        );
        // Build simple indexes for performance
        this._makeIdx = { indoor: new Map(), outdoor: new Map() };
        for(const env of ['indoor','outdoor']){
          for(const r of (make.byEnv[env]||[])){
            const key = this._mkKey({
              env,
              distance: r.distance,
              tF: r.temp_F,
              wMph: r.wind_mph,
              wHead: r.wind_head_mps,
              wCross: r.wind_cross_mps,
              alt: r.altitude_m
            });
            this._makeIdx[env].set(key, r);
          }
        }
        this._attemptIdx = new Map();
        for(const r of attempt.rows){
          const key = this._atKey(r.env, r.distance, r.score_bin, r.time_bin, r.ytg_bin, r.hash);
          this._attemptIdx.set(key, r);
        }
        // Roster quick maps
        this._teams = this._roster.map(r=>r.team);
        this._kickersByTeam = new Map(this._roster.map(r=>[r.team, r.kickers || []]));
      }
  
      // ----------- keys -----------
      _mkKey({ env, distance, tF, wMph, wHead, wCross, alt }){
        const dR = Math.round(+distance);
        const tR = Math.round(+tF/5)*5;       // 5°F bins
        const wR = Math.round(+wMph/2)*2;     // 2 mph bins
        const hR = Math.round((+wHead||0)*1000)/1000;
        const cR = Math.round((+wCross||0)*1000)/1000;
        const aR = Math.round((+alt||0)/50)*50;

        // Build key parts only for axes the grid actually has
        const parts = [env, dR, tR];
        if (this.hasDirAxis) parts.push(wR, hR, cR);
        else                 parts.push(wR);
        if (this.hasAltAxis) parts.push(aR);
        return parts.join('|');
      }
  
      // ----------- getters -----------
      getVersions(){
        const dataV = this._manifest?.generated_at_epoch ? new Date(this._manifest.generated_at_epoch*1000).toISOString() : 'local';
        const schemaV = 'make:v'+this._make.schema+' attempt:v'+this._attempt.schema;
        return { data: dataV, schema: schemaV };
      }
      getRoster(){ return this._roster; }
      getTeams(){ return this._teams.slice(); }
      getKickers(team){ return this._kickersByTeam.get(team)||[]; }
  
      // League make probability (no kicker deltas applied)
      // Replace your getMakeProb with this version
      getMakeProb({
        env = 'indoor',
        distance,
        temp_F = 60,
        wind_mph = 0,
        wind_head_mps = null,
        wind_cross_mps = null,
        altitude_m = 0,
        stadiumId = null
      }) {
        // 1) Venue-normalized inputs (wind attenuation, indoor wind=0, v1 altitude fallback)
        const adj = this._applyVenueAdjustments({
          stadiumId,
          env,
          distance,
          temp_F,
          wind_mph,
          wind_head_mps: wind_head_mps ?? 0,
          wind_cross_mps: wind_cross_mps ?? 0,
          altitude_m
        });

        // 2) Schema-aware alignment for keying
        const gridSchema = this._make?.schema || 1;

        // Always use the binned/rounded mph; head/cross only matter in v2+
        let keyWindMph   = adj.wind_mph;
        let keyHeadMps   = adj.wind_head_mps;
        let keyCrossMps  = adj.wind_cross_mps;
        let keyAltMeters = adj.altitude_m;

        if (gridSchema < 2) {
          // v1 grid has speed only; rows were indexed with: head_mps = wind_mph*0.44704, cross=0, altitude=0
          keyHeadMps   = Math.abs(keyWindMph) * 0.44704;
          keyCrossMps  = 0;
          keyAltMeters = 0;
        }

        const key = this._mkKey({
          env,
          distance: adj.distance,
          tF: adj.temp_F,
          wMph: adj.wind_mph,
          wHead: adj.wind_head_mps,
          wCross: adj.wind_cross_mps,
          alt: adj.altitude_m
        });

        // 3) Lookup (with distance-only fallback)
        let row = this._makeIdx[env].get(key);
        if (!row) {
          const pool = this._make.byEnv[env] || [];
          let best = null, bd = 1e9;
          for (const r of pool) {
            const d = Math.abs(r.distance - adj.distance);
            if (d < bd) { bd = d; best = r; }
          }
          row = best;
        }

        return row ? +row.prob_mean : 0.5;
      }


      // Kicker delta on logit scale
      getKickerDeltaLogit(kickerId, distance){
        const kid = String(kickerId||'');
        if(!kid) return { delta_logit: 0, se: 0 };
        if(this._deltas.kind==='by_distance'){
          const obj = this._deltas.map.get(kid);
          if(!obj) return { delta_logit: 0, se: 0 };
          const byD = obj.by_distance || {};
          const d = Math.round(distance);
          const hit = byD[d] || byD[d-1] || byD[d+1] || null;
          return hit ? { delta_logit: +hit.delta_logit, se: +hit.se||0 } : { delta_logit: 0, se: 0 };
        }
        // banded with blend around thresholds
        const entry = this._deltas.map.get(kid);
        if(!entry) return { delta_logit: 0, se: 0 };
        const band = bandForDistance(distance);
        const bands = entry.bands || {};
        const BLEND = 2; // yards
        const bounds = { short:39, mid:49, long:59 };
        function wts(d){
          if(d <= bounds.short - BLEND) return {short:1};
          if(d < bounds.short + BLEND){ const t=(d-(bounds.short-BLEND))/(2*BLEND); return {short:1-t, mid:t}; }
          if(d <= bounds.mid - BLEND) return {mid:1};
          if(d < bounds.mid + BLEND){ const t=(d-(bounds.mid-BLEND))/(2*BLEND); return {mid:1-t, long:t}; }
          if(d <= bounds.long - BLEND) return {long:1};
          if(d < bounds.long + BLEND){ const t=(d-(bounds.long-BLEND))/(2*BLEND); return {long:1-t, xlong:t}; }
          return {xlong:1};
        }
        const w = wts(distance);
        let dl=0, varSum=0; for(const [k,wt] of Object.entries(w)){
          const b = bands[k]; if(!b) continue; const se = +b.se||0; dl += wt*(+b.delta_logit||0); varSum += wt*wt*se*se;
        }
        return { delta_logit: dl, se: Math.sqrt(varSum) };
      }

      // Optional: coupled attempt given kicker delta and sensitivity
      getCoupledAttemptProb({
        env = 'indoor',
        distance,
        score_bin = 'close',
        time_bin = 'mid',
        ytg_bin = 'med',
        kickerId = null,
        temp_F = 60,
        wind_mph = 0,
        wind_head_mps = null,
        wind_cross_mps = null,
        altitude_m = 0,
        stadiumId = null
      }){
        // Base attempt (context-only)
        const pA = this.getAttemptProb({ env, distance, score_bin, time_bin, ytg_bin });

        // League make under venue-adjusted conditions
        const pM_league = this.getMakeProb({
          env, distance, temp_F,
          wind_mph, wind_head_mps, wind_cross_mps,
          altitude_m, stadiumId
        });

        // Kicker-adjusted make (no shrink here; charts may apply their own)
        const { delta_logit: dK } = this.getKickerDeltaLogit(kickerId, distance);
        const pM_kicker = sigmoid(logit(pM_league) + dK);

        // Sensitivity coupling
        const { A, B, C } = this._sens;
        const lp = A + C * logit(pA) + B * (logit(pM_kicker) - logit(pM_league));
        return sigmoid(lp);
      }
    }
  
    function logit(p){ p=Math.min(Math.max(p,1e-9),1-1e-9); return Math.log(p/(1-p)); }
    function sigmoid(x){ return 1/(1+Math.exp(-x)); }
  
    // Expose class too (for testing), but keep singleton on FG.DataStore from init()
    window.FG = window.FG || {};
    window.FG.DataStoreClass = DataStore;

    (async () => {
      await (window.FG?.ready?.());
      window.state = window.state || {};
      window.FG?.emitState?.({ ...window.state });
    })();
  })();
  </script>

  <!-- =========================
FG Pro UI v4 — Part 3/6 (Selectors)
Paste the HTML fragment into the LEFT RAIL (inside <main> -> <aside>), above the "Scenario" card.
Paste the <script> block near the end of index.html, AFTER Part 2 (Data Loader) script.
All IDs coexist with Part 1; this adds a left-rail selector and syncs with top-bar selects.
========================= -->



<!-- =========================
  SCRIPT: Wiring for selectors + slider paint + event emission
========================= -->
<script>
(function(){
  if (window.__fgSelectorsInitRan) return; 
    window.__fgSelectorsInitRan = true;
  // Ensure FG namespace exists (from Part 2)
  window.FG = window.FG || {};

  // Grab existing global state from Part 1 or create one
  const state = window.state || (window.state = {
    team: '',
    kicker: '',
    env: 'indoor',
    alt: 'sea',
    distance: 45,
    tempF: 60,
    wind: 5,
    windDir: 'calm',
    scoreBin: 'close',
    timeBin: 'mid',
    ytgBin: 'med'
  });

  // Refs (top bar & left rail — keep them in sync)
  const teamTop   = document.getElementById('teamSelect');
  const kickerTop = document.getElementById('kickerSelect');
  const teamLR    = document.getElementById('teamSelectLR');
  const kickerLR  = document.getElementById('kickerSelectLR');

  const envIndoorBtn = document.getElementById('envIndoor');
  const envOutdoorBtn= document.getElementById('envOutdoor');

  const distance = document.getElementById('distance');
  const temp     = document.getElementById('temp');
  const wind     = document.getElementById('wind');
  const distanceVal = document.getElementById('distanceVal');
  const tempVal     = document.getElementById('tempVal');
  const windVal     = document.getElementById('windVal');

  const windDirCard = document.getElementById('windDirCard');

  const NFL_TEAMS = [
    'ARI','ATL','BAL','BUF','CAR','CHI','CIN','CLE','DAL','DEN','DET','GB','HOU','IND','JAX','KC','LAC','LAR','MIA','MIN','NE','NO','NYG','NYJ','LV','PHI','PIT','SEA','SF','TB','TEN','WAS'
  ];

  function emitState(){
    window.FG?.emitState?.({ ...state });
  }

  // ---------- Range track paint with danger zone (62–68 yd) ----------
  function paintDistanceTrack(){
    if(!distance) return;
    const min=+distance.min||18, max=+distance.max||68, v=+distance.value;
    const pct = (v-min)/(max-min)*100;
    const dangerStart = ((62-min)/(max-min))*100; // ~88%
    const grad = `linear-gradient(90deg, #3b82f6 0% ${pct}%, #e5e7eb ${pct}% ${dangerStart}%, #ef4444 ${dangerStart}% 100%)`;
    distance.style.background = grad;
  }
  if(distance){ distance.addEventListener('input', paintDistanceTrack); paintDistanceTrack(); }

  // ---------- Helpers ----------
  function option(label, value, extra={}){
    const o = document.createElement('option');
    o.textContent = label; o.value = value;
    if(extra.disabled){ o.disabled = true; o.textContent += ' (inactive)'; }
    if(extra.selected){ o.selected = true; }
    return o;
  }

  function syncSelectValues(){
    if(teamTop) teamTop.value = state.team || '';
    if(teamLR)  teamLR.value  = state.team || '';
    if(kickerTop) kickerTop.value = state.kicker || '';
    if(kickerLR)  kickerLR.value  = state.kicker || '';
  }

  function setEnv(which){
    state.env = which;
    envIndoorBtn?.classList.toggle('on', which==='indoor');
    envIndoorBtn?.classList.toggle('off', which!=='indoor');
    envIndoorBtn?.setAttribute('aria-pressed', String(which==='indoor'));
    envOutdoorBtn?.classList.toggle('on', which==='outdoor');
    envOutdoorBtn?.classList.toggle('off', which!=='outdoor');
    envOutdoorBtn?.setAttribute('aria-pressed', String(which==='outdoor'));
    emitState();
  }

  function bindWindDir(){
    if(!windDirCard) return;
    const btns = [...windDirCard.querySelectorAll('button[data-dir]')];
    function set(which){
      state.windDir = window.FG?.norm?.windDir(which);
      for(const b of btns){
        const on = b.dataset.dir===which; b.classList.toggle('on', on); b.classList.toggle('off', !on); b.setAttribute('aria-pressed', String(on));
      }
      emitState();
    }
    btns.forEach(b=> b.addEventListener('click', ()=> set(b.dataset.dir)));
    set(state.windDir||'calm');
  }

  async function fetchText(url){
  try{ const r = await fetch(url, {cache:'no-store'}); if(!r.ok) return null; return await r.text(); }catch{ return null; }
}
function parseCSVRow(line){
  let out=[],cur='',q=false;
  for(let i=0;i<line.length;i++){
    const c=line[i];
    if(q){ if(c=='"'){ if(line[i+1]=='"'){cur+='"';i++;} else {q=false;} } else {cur+=c;} }
    else { if(c=='"'){q=true;} else if(c==','){ out.push(cur); cur=''; } else {cur+=c;} }
  }
  out.push(cur); return out.map(s=>s.trim());
}
function parseCSV(txt){
  if(!txt) return {head:[],rows:[]};
  const lines = txt.replace(/\r/g,'').split('\n').filter(l=>l.trim());
  const head = parseCSVRow(lines.shift());
  const rows = lines.map(l=>parseCSVRow(l));
  return { head, rows };
}
async function deriveTeamsFromDepthCharts(csvUrl){
  const txt = await fetchText(csvUrl); if(!txt) return null;
  const { head, rows } = parseCSV(txt);
  const idx = Object.fromEntries(head.map((h,i)=>[h,i]));
  const set = new Set();
  for(const r of rows){
    const code = r[idx.club_code] || r[idx.club] || r[idx.team] || '';
    if(code) set.add(code.toUpperCase());
  }
  const list = Array.from(set).sort();
  return list.length ? list : null;
}


  // ---------- Populate from DataStore ----------
  async function initSelectors(){
    // Ensure DataStore is ready
    const ds = await window.FG?.ready?.();

    // Teams
    let teams = ds?.getTeams?.() ?? [];
    if (!teams.length) {
      try {
        teams = (await deriveTeamsFromDepthCharts('./depth_charts.csv')) ?? [];
      } catch { /* noop */ }
    }
    if (!teams.length) teams = NFL_TEAMS;

    // Populate team selects
    if (teamTop){
      teamTop.innerHTML = '';
      teamTop.appendChild(option('— select —',''));
      for (const t of teams) teamTop.appendChild(option(t,t));
    }
    if (teamLR){
      teamLR.innerHTML = '';
      teamLR.appendChild(option('— select —',''));
      for (const t of teams) teamLR.appendChild(option(t,t));
    }

    // Team → kicker binding (works with DataStore v2 or bootstrap roster)
    function fillKickers(team){
      const top  = document.getElementById('kickerSelect');
      const left = document.getElementById('kickerSelectLR');

      const setDisabled = (el, msg) => {
        if(!el) return;
        el.innerHTML = '';
        el.appendChild(option(msg, ''));
        el.disabled = true;
      };

      const enable = (el) => { if(el){ el.disabled = false; el.removeAttribute('disabled'); } };

      // No team yet
      if(!team || !(ds?.getKickersByTeam || ds?.getKickers)){
        setDisabled(top,  '— select team first —');
        setDisabled(left, '— select team first —');
        return '';
      }

      const list = (ds.getKickersByTeam ? ds.getKickersByTeam(team) : ds.getKickers(team)) || [];
      if(!list.length){
        setDisabled(top,  '— no kickers —');
        setDisabled(left, '— no kickers —');
        return '';
      }

      const isStarter = k => !!(k.isStarter || k.starter);
      const isActive  = k => (k.active !== false) && !/inactive|ir|retired|practice/i.test(String(k.status||''));
      const prevId    = window.state?.kicker ? String(window.state.kicker) : '';

      const apply = (el) => {
        if(!el) return;
        el.innerHTML = '';
        for(const k of list){
          const label = `${k.name}${isStarter(k) ? ' (starter)' : ''}${isActive(k) ? '' : ' [inactive]'}`;
          el.appendChild(option(label, String(k.id), { disabled: !isActive(k) }));
        }
        enable(el);
      };

      apply(top); apply(left);

      const hasPrev     = prevId && list.some(k => String(k.id) === prevId && isActive(k));
      const starter     = list.find(isStarter);
      const firstActive = list.find(isActive) || list[0];
      const selectedId  = String(hasPrev ? prevId : (starter?.id ?? firstActive?.id ?? ''));

      if(top)  top.value  = selectedId;
      if(left) left.value = selectedId;

      return selectedId;
    }

    function onTeamChange(newTeam){
      state.team = newTeam || '';

      // Fill both kicker dropdowns
      fillKickers(kickerTop, state.team);
      fillKickers(kickerLR,  state.team);

      // Choose selected kicker coherently across both
      const pick =
        (kickerLR && kickerLR.value) ||
        (kickerTop && kickerTop.value) ||
        '';

      state.kicker = String(pick || '');
      syncSelectValues();
      emitState();
    }

    function onKickerChange(newKicker){
      state.kicker = newKicker || '';
      syncSelectValues();
      emitState();
    }

    // Initial defaults — pick first team (populates kickers & selects a default)
    const firstTeam = teams[0] || '';
    onTeamChange(firstTeam);

    // Bind changes (top and left)
    FG.on(teamTop,  'change', ()=> onTeamChange(teamTop.value),  'teamTop:change');
    FG.on(teamLR,   'change', ()=> onTeamChange(teamLR.value),   'teamLR:change');
    FG.on(kickerTop,'change', ()=> onKickerChange(kickerTop.value),'kTop:change');
    FG.on(kickerLR, 'change', ()=> onKickerChange(kickerLR.value),'kLR:change');

    // Env + sliders
    FG.on(envIndoorBtn,  'click', ()=> setEnv('indoor'),  'env:indoor');
    FG.on(envOutdoorBtn, 'click', ()=> setEnv('outdoor'), 'env:outdoor');

    const syncSliders = ()=>{
      state.distance = +distance.value; distanceVal && (distanceVal.textContent = state.distance);
      state.tempF    = +temp.value;     tempVal     && (tempVal.textContent     = state.tempF);
      state.wind     = +wind.value;     windVal     && (windVal.textContent     = state.wind);
      paintDistanceTrack();
      emitState();
    };
    FG.on(distance, 'input', syncSliders, 'dist:input');
    FG.on(temp,     'input', syncSliders, 'temp:input');
    FG.on(wind,     'input', syncSliders, 'wind:input');

    bindWindDir();

    // Emit initial
    window.FG?.emitState?.({ ...state });
  }

  // Kick off after DOM is ready
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initSelectors);
  }else{ initSelectors(); }
})();
</script>

<!-- =========================
FG Pro UI v4 — Part 4/6 (Make% Chart)
Paste this <script> block near the end of index.html, AFTER Parts 1–3.
Requires FG.DataStore (Part 2) and global `state` (Part 1/3).
Canvas-based; no external chart libs.
========================= -->
<script>
  (function(){
    const DMIN=18, DMAX=68;
    const PX = (v)=>Math.max(0, Math.round(v));
  
    // Lightweight tooltip
    function makeTooltip(host){
      const tip = document.createElement('div');
      tip.style.position='fixed'; tip.style.pointerEvents='none';
      tip.style.padding='6px 8px'; tip.style.font='12px/1.3 ui-sans-serif,system-ui';
      tip.style.background='rgba(17,24,39,.92)'; tip.style.color='#fff'; tip.style.borderRadius='8px';
      tip.style.boxShadow='0 8px 24px rgba(0,0,0,.24)'; tip.style.zIndex=9998; tip.style.display='none';
      host.appendChild(tip);
      return {
        show(x,y,html){ tip.innerHTML=html; tip.style.left=(x+14)+'px'; tip.style.top=(y+14)+'px'; tip.style.display='block'; },
        hide(){ tip.style.display='none'; }
      };
    }
  
    function logit(p){ p=Math.min(Math.max(+p,1e-9),1-1e-9); return Math.log(p/(1-p)); }
    function sigmoid(x){ return 1/(1+Math.exp(-x)); }
  
    class MakeChart {
      constructor(container){
        this.root = typeof container==='string' ? document.querySelector(container) : container;
        this.canvas = document.createElement('canvas');
        this.canvas.style.width='100%'; this.canvas.style.height='100%';
        this.canvas.style.display='block';
        this.overlay = document.createElement('canvas');
        this.overlay.style.position='absolute'; this.overlay.style.left=0; this.overlay.style.top=0; this.overlay.style.width='100%'; this.overlay.style.height='100%'; this.overlay.style.pointerEvents='none';
        this.host = document.createElement('div');
        this.host.className='relative w-full h-full';
        this.host.appendChild(this.canvas); this.host.appendChild(this.overlay);
        this.root.innerHTML=''; this.root.appendChild(this.host);
  
        this.ctx = this.canvas.getContext('2d');
        this.octx = this.overlay.getContext('2d');
        this.tooltip = makeTooltip(document.body);
  
        this.ds = null; this.state = null; this.quantiles = null; // optional p10/p90 by distance
  
        this._ro = new ResizeObserver(()=> this.resize());
        this._ro.observe(this.root);
  
        this._mouseCanvas = document.createElement('canvas');
        this._mouseCanvas.style.position='absolute'; this._mouseCanvas.style.inset=0; this._mouseCanvas.style.background='transparent';
        this._mouseCanvas.style.cursor='crosshair';
        this.host.appendChild(this._mouseCanvas);
        this._mouseCanvas.addEventListener('mousemove', (e)=> this.onHover(e));
        this._mouseCanvas.addEventListener('mouseleave', ()=> this.tooltip.hide());
      }
  
      async setDataStore(ds){
        this.ds = ds || window.FG?.DataStore || await window.FG?.DataStoreClass?.init?.({ baseUrl: '.' });
        this.resize();
        await this._maybeLoadQuantiles();
        this.render();
      }
      setState(state){ this.state = state; this.render(); }
  
      resize(){
        const dpr = Math.min(2, window.devicePixelRatio||1);
        const w = this.root.clientWidth||800; const h = this.root.clientHeight||360;
        for(const c of [this.canvas, this.overlay, this._mouseCanvas]){
          c.width = PX(w*dpr); c.height = PX(h*dpr); c.style.width=w+'px'; c.style.height=h+'px';
          const ctx = c.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0);
        }
        this.render();
      }
  
      // Try to read p10/p90 from the make grid file directly (optional)
      async _maybeLoadQuantiles(){
        try{
          const res = await fetch('./fg_prob_grid_distance_env_temp_wind.json', { cache: 'no-store' });
          if(!res.ok) return; const obj = await res.json();
          const env = (this.state?.env)||'indoor';
          // Use same rounding as DataStore (5F, 2mph)
          const tF = Math.round((this.state?.tempF ?? 60)/5)*5;
          const wM = Math.round((this.state?.wind ?? 0)/2)*2;
          const rows = (obj?.grid||[]).filter(r=> (r.indoor_outdoor||r.env)==env && (+r.temp_F)==tF && (+r.wind_mph)==wM);
          if(!rows.length) return;
          this.quantiles = new Map();
          for(const r of rows){
            if(r.prob_p10!=null && r.prob_p90!=null){ this.quantiles.set(+r.distance, {p10:+r.prob_p10, p90:+r.prob_p90}); }
          }
        }catch{ /* optional */ }
      }
  
      _calcSeries(){
        const s = this.state || {};
        const ds = this.ds; if(!ds) return null;
        const env = s.env||'indoor';
        const kid = s.kicker || null;
        const tF  = s.tempF ?? 60;
        const mph = Number(s.wind ?? 0);
        let head=0, cross=0;
        switch(String(s.windDir||'calm')){
          case 'head':   head =  mph; break;
          case 'tail':   head = -mph; break;
          case 'crossL': cross = -mph; break;
          case 'crossR': cross =  mph; break;
        }
        const altitude_m = Number(s.altitude_m ?? (s.alt==='high'?1600 : s.alt==='mid'?500 : 0)) || 0;
  
        const x = []; const league = []; const kicker = [];
        const p10=[]; const p90=[]; // optional
        for(let d=DMIN; d<=DMAX; d++){
          x.push(d);
          const pL = ds.getMakeProb({
            env, distance:d, temp_F:tF,
            wind_mph:mph, wind_head_mps: head*0.44704, wind_cross_mps: cross*0.44704,
            altitude_m,
            stadiumId: (this.state?.stadiumId || null)
          });
          let dK = 0, se=0; const del = ds.getKickerDeltaLogit(kid, d) || {delta_logit:0,se:0};
          dK = +del.delta_logit||0; se=+del.se||0;
          // Shrink delta by its uncertainty (stable default)
          const w = 1 / (1 + Math.pow(se/0.8, 2));
          const pK = sigmoid(logit(pL) + dK * w);
          league.push(pL); kicker.push(pK);
          if(this.quantiles && this.quantiles.has(d)){
            const q = this.quantiles.get(d); p10.push(q.p10); p90.push(q.p90);
          } else { p10.push(null); p90.push(null); }
        }
        return { x, league, kicker, p10, p90 };
      }
  
      onHover(evt){
        const rect = this.canvas.getBoundingClientRect();
        const x = evt.clientX - rect.left; const y = evt.clientY - rect.top;
        const st = this._scales; if(!st) return;
        const dApprox = Math.round(st.xi(x));
        const d = Math.min(DMAX, Math.max(DMIN, dApprox));
        const s = this._series; if(!s) return;
        const idx = d-DMIN; const pL = s.league[idx]; const pK = s.kicker[idx];
        const deltaPct = ((pK-pL)*100).toFixed(1);
        const html = `<div><b>${d} yards</b></div>
                      <div>League: ${(pL*100).toFixed(1)}%</div>
                      <div>Kicker: ${(pK*100).toFixed(1)}% <span style="opacity:.7">(${deltaPct}% Δ)</span></div>`;
        this.tooltip.show(evt.clientX, evt.clientY, html);
        this._drawHover(d);
      }
  
      _drawAxes(ctx, W, H, pad){
        ctx.clearRect(0,0,W,H);
        ctx.save();
        ctx.translate(pad.l, pad.t); const w=W-pad.l-pad.r, h=H-pad.t-pad.b;
  
        // grid lines
        ctx.strokeStyle='#e5e7eb'; ctx.lineWidth=1;
        ctx.beginPath();
        for(let gy=0; gy<=10; gy++){
          const y = h - h*(gy/10); ctx.moveTo(0,y); ctx.lineTo(w,y);
        }
        for(let gx=0; gx<=5; gx++){
          const x = w*(gx/5); ctx.moveTo(x,0); ctx.lineTo(x,h);
        }
        ctx.stroke();
  
        // axes labels
        ctx.fillStyle='#334155'; ctx.font='12px ui-sans-serif,system-ui'; ctx.textAlign='right';
        for(let gy=0; gy<=10; gy+=2){ const v=gy*10; const y=h - h*(gy/10); ctx.fillText(v+'%', -6, y+4); }
        ctx.textAlign='center';
        for(let d=20; d<=68; d+=8){ const x = w*( (d-DMIN)/(DMAX-DMIN) ); ctx.fillText(d+'y', x, h+18); }
  
        ctx.restore();
      }
  
      _drawSeries(ctx, W, H, pad, series){
        ctx.save(); ctx.translate(pad.l, pad.t); const w=W-pad.l-pad.r, h=H-pad.t-pad.b;
  
        const x = (d)=> w*( (d-DMIN)/(DMAX-DMIN) );
        const y = (p)=> h*(1-p);
        this._scales = { x, y, xi:(px)=> (px - pad.l)/(W-pad.l-pad.r)*(DMAX-DMIN)+DMIN };
  
        // 60+ shaded band
        const x60 = x(60); ctx.fillStyle='rgba(239,68,68,.10)'; ctx.fillRect(x60, 0, w-x60, h);
  
        // p10-p90 band if available
        if(series.p10.some(v=>v!=null) && series.p90.some(v=>v!=null)){
          ctx.fillStyle='rgba(31,41,55,.10)';
          ctx.beginPath();
          // top (p90)
          for(let d=DMIN; d<=DMAX; d++){
            const i=d-DMIN; const px=x(d), py=y(series.p90[i]??series.league[i]);
            if(d===DMIN) ctx.moveTo(px,py); else ctx.lineTo(px,py);
          }
          // back along bottom (p10)
          for(let d=DMAX; d>=DMIN; d--){
            const i=d-DMIN; const px=x(d), py=y(series.p10[i]??series.league[i]);
            ctx.lineTo(px,py);
          }
          ctx.closePath(); ctx.fill();
        }
  
        // League curve
        ctx.strokeStyle='#3b82f6'; ctx.lineWidth=2.25; ctx.beginPath();
        for(let d=DMIN; d<=DMAX; d++){
          const i=d-DMIN; const px=x(d), py=y(series.league[i]);
          if(d===DMIN) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.stroke();
  
        // Kicker curve
        ctx.strokeStyle='#f59e0b'; ctx.lineWidth=2; ctx.beginPath();
        for(let d=DMIN; d<=DMAX; d++){
          const i=d-DMIN; const px=x(d), py=y(series.kicker[i]);
          if(d===DMIN) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.stroke();
  
        // Legend
        ctx.fillStyle='#0f172a'; ctx.font='12px ui-sans-serif,system-ui';
        function swatch(x0,y0,color,label){ ctx.fillStyle=color; ctx.fillRect(x0,y0,14,3); ctx.fillStyle='#0f172a'; ctx.fillText(label, x0+20, y0+4); }
        swatch(8, 10, '#3b82f6', 'League make%');
        swatch(8, 28, '#f59e0b', 'Kicker-adjusted');
  
        ctx.restore();
      }
  
      _drawHover(d){
        const W=this.overlay.width/(window.devicePixelRatio||1), H=this.overlay.height/(window.devicePixelRatio||1);
        const pad={l:48,t:16,r:16,b:28}; const w=W-pad.l-pad.r, h=H-pad.t-pad.b;
        const x = (dd)=> w*( (dd-DMIN)/(DMAX-DMIN) );
        const y = (p)=> h*(1-p);
        const i=d-DMIN; const s=this._series; if(!s) return;
  
        this.octx.setTransform(1,0,0,1,0,0); this.octx.clearRect(0,0,W,H); this.octx.setTransform(window.devicePixelRatio||1,0,0,window.devicePixelRatio||1,0,0);
        this.octx.translate(pad.l,pad.t);
        this.octx.strokeStyle='rgba(15,23,42,.25)'; this.octx.beginPath(); this.octx.moveTo(x(d),0); this.octx.lineTo(x(d),h); this.octx.stroke();
        this.octx.fillStyle='#3b82f6'; this.octx.beginPath(); this.octx.arc(x(d), y(s.league[i]), 3.5, 0, Math.PI*2); this.octx.fill();
        this.octx.fillStyle='#f59e0b'; this.octx.beginPath(); this.octx.arc(x(d), y(s.kicker[i]), 3.5, 0, Math.PI*2); this.octx.fill();
      }
  
      render(){
        if(!this.root || !this.ctx) return;
        if(!this.ds || !this.state){
          const ctx=this.ctx, W=this.canvas.width/(window.devicePixelRatio||1), H=this.canvas.height/(window.devicePixelRatio||1);
          ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,W,H); ctx.font='12px ui-sans-serif,system-ui'; ctx.fillStyle='#64748b'; ctx.fillText('Loading data…', 12, 18); return;
        }
        this._series = this._calcSeries();
        const series = this._series;
        const W=this.canvas.width/(window.devicePixelRatio||1), H=this.canvas.height/(window.devicePixelRatio||1);
        const pad={l:48,t:16,r:16,b:28};
        this._drawAxes(this.ctx, W, H, pad);
        this._drawSeries(this.ctx, W, H, pad, series);
        this.octx.clearRect(0,0,this.overlay.width,this.overlay.height);
      }
    }
  
    // Mount into #makeChart stub
    async function mount(){
      const el = document.getElementById('makeChart'); 
      if(!el || !window.FG?.mountOnce?.(el, 'makeChart')) return;   // guard
      const chart = new MakeChart(el);
      const ds = await window.FG?.ready?.();
      chart.setState(window.state||{});
      await chart.setDataStore(ds);

      window.FG?.on(window, 'fg:stateChanged', (e)=>{
        chart.setState(e.detail||window.state||{});
        chart._maybeLoadQuantiles();
        chart.render();
      }, 'makeChart:state');
    }
    if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', mount, { once:true }); else mount();

  })();
  </script>
  
<!-- =========================
FG Pro UI v4 — Part 5/6 (Attempt% + Coupling)
Paste this <script> block near the end of index.html AFTER Parts 1–4.
Requires FG.DataStore (Part 2) and global `state` (Part 1/3).
Canvas-based attempt chart + coupling, with compare Starter vs Backup toggle.
========================= -->
<script>
  (function(){
    const DMIN=18, DMAX=68;
    const PX = (v)=>Math.max(0, Math.round(v));
  
    function logit(p){ p=Math.min(Math.max(+p,1e-9),1-1e-9); return Math.log(p/(1-p)); }
    function sigmoid(x){ return 1/(1+Math.exp(-x)); }
  
    // Tiny tooltip
    function makeTooltip(host){
      const tip = document.createElement('div');
      tip.style.position='fixed'; tip.style.pointerEvents='none'; tip.style.padding='6px 8px';
      tip.style.font='12px/1.3 ui-sans-serif,system-ui'; tip.style.background='rgba(17,24,39,.92)';
      tip.style.color='#fff'; tip.style.borderRadius='8px'; tip.style.boxShadow='0 8px 24px rgba(0,0,0,.24)'; tip.style.zIndex=9998; tip.style.display='none';
      host.appendChild(tip);
      return { show(x,y,html){ tip.innerHTML=html; tip.style.left=(x+14)+'px'; tip.style.top=(y+14)+'px'; tip.style.display='block'; }, hide(){ tip.style.display='none'; } };
    }
  
    class AttemptChart {
      constructor(container){
        this.root = typeof container==='string' ? document.querySelector(container) : container;
        this.canvas = document.createElement('canvas');
        this.canvas.style.width='100%'; this.canvas.style.height='340px'; this.canvas.style.display='block';
        this.overlay = document.createElement('canvas');
        this.overlay.style.position='absolute'; this.overlay.style.left=0; this.overlay.style.top=0; this.overlay.style.width='100%'; this.overlay.style.height='340px'; this.overlay.style.pointerEvents='none';
        this.host = document.createElement('div'); this.host.className='relative w-full';
        this.host.appendChild(this.canvas); this.host.appendChild(this.overlay);
  
        // Controls + info area (under canvas)
        this.ctrl = document.createElement('div');
        this.ctrl.className='mt-2 flex flex-wrap items-center gap-3 text-sm';
        this.info = document.createElement('div');
        this.info.className='mt-2 text-xs text-ink-700';
  
        const parentCard = document.getElementById('attemptTab');
        const chartStub = document.getElementById('attemptChart');
        if(chartStub){ chartStub.replaceWith(this.host); }
        parentCard?.appendChild(this.ctrl); parentCard?.appendChild(this.info);
  
        this.ctx = this.canvas.getContext('2d'); this.octx = this.overlay.getContext('2d'); this.tooltip = makeTooltip(document.body);
        this._ro = new ResizeObserver(()=> this.resize()); this._ro.observe(this.host);
  
        // Compare toggle
        this.compare = false; this._buildControls();
  
        // Mouse layer
        this._mouseCanvas = document.createElement('canvas');
        this._mouseCanvas.style.position='absolute'; this._mouseCanvas.style.inset=0; this._mouseCanvas.style.background='transparent'; this._mouseCanvas.style.cursor='crosshair';
        this.host.appendChild(this._mouseCanvas);
        this._mouseCanvas.addEventListener('mousemove', (e)=> this.onHover(e));
        this._mouseCanvas.addEventListener('mouseleave', ()=> this.tooltip.hide());
  
        this.ds=null; this.state=null; this._series=null; this._scales=null;
      }
  
      _buildControls(){
        this.ctrl.innerHTML='';
        const pill = document.createElement('div'); pill.className='seg';
        const s1 = document.createElement('button'); s1.textContent='Single'; s1.className='on';
        const s2 = document.createElement('button'); s2.textContent='Compare starter vs backup'; s2.className='off';
        pill.appendChild(s1); pill.appendChild(s2);
        this.ctrl.appendChild(pill);
        const note = document.createElement('span'); note.className='text-xs text-ink-500'; note.textContent='If no backup exists, comparison is disabled.';
        this.ctrl.appendChild(note);
        const that=this;
        function set(mode){ that.compare=(mode==='compare'); s1.classList.toggle('on', !that.compare); s1.classList.toggle('off', that.compare); s2.classList.toggle('on', that.compare); s2.classList.toggle('off', !that.compare); that.render(); }
        s1.addEventListener('click', ()=> set('single'));
        s2.addEventListener('click', ()=> set('compare'));
      }
  
      async setDataStore(ds){ this.ds = ds || window.FG?.DataStore || await window.FG?.DataStoreClass?.init?.({ baseUrl: '.' }); this.resize(); this.render(); }
      setState(s){ this.state = s; this.render(); }
  
      resize(){
        const dpr = Math.min(2, window.devicePixelRatio||1);
        const w = this.host.clientWidth||800; const h = 340;
        for(const c of [this.canvas,this.overlay,this._mouseCanvas]){ c.width=PX(w*dpr); c.height=PX(h*dpr); c.style.width=w+'px'; c.style.height=h+'px'; c.getContext('2d').setTransform(dpr,0,0,dpr,0,0); }
        this.render();
      }
  
      _findStarterAndBackup(){
        const ds=this.ds, st=this.state; if(!ds||!st?.team) return {starter:null, backup:null};
        const ks = ds.getKickers(st.team)||[]; if(!ks.length) return {starter:null, backup:null};
        const starter = ks.find(k=>!!k.starter) || ks[0];
        const backup = ks.find(k=> String(k.id)!==String(starter.id) && (k.active!==false) );
        return {starter, backup};
      }
  
      _calcSeries(){
        const ds=this.ds, st=this.state; if(!ds||!st) return null;
        const env = st.env || 'indoor';
        function binsFromExact(score, sec, ytg){
          const s = (score<=-3) ? 'trail' : (score>=3 ? 'lead' : 'close');
          const t = (sec<=240) ? 'late'  : (sec<=660 ? 'mid' : 'early'); // <=4:00 late; <=11:00 mid
          const y = (ytg<=3)   ? 'short' : (ytg<=6   ? 'med' : 'long');
          return { s, t, y };
        }
        const { s, t, y } = binsFromExact(st.scoreDiffExact ?? 0, st.timeRemSec ?? 900, st.ytgExact ?? 5);
        const {starter, backup} = this._findStarterAndBackup();
        const kid = st.kicker || starter?.id || null;
        const mph = Number(st.wind||0);
        let head=0, cross=0;
        const safeDir = window.FG?.norm?.windDir(st.windDir) || 'calm';
        switch(safeDir){
          case 'head': head=mph; break;
          case 'tail': head=-mph; break;
          case 'crossL': cross=-mph; break;
          case 'crossR': cross=mph; break;
        }
        const altitude_m = Number(st.altitude_m ?? (st.alt==='high'?1600 : st.alt==='mid'?500 : 0)) || 0;
          
        const x=[], base=[], coupStarter=[], coupBackup=[];
        for(let d=DMIN; d<=DMAX; d++){
          const pA = ds.getAttemptProb({ env, distance:d, score_bin:s, time_bin:t, ytg_bin:y });
          base.push(pA);
          const pCoupledStarter = ds.getCoupledAttemptProb({
            env, distance:d, score_bin:s, time_bin:t, ytg_bin:y, kickerId:kid,
            temp_F: st.tempF||60,
            wind_mph: mph, wind_head_mps: head*0.44704, wind_cross_mps: cross*0.44704,
            altitude_m,
            stadiumId: (st.stadiumId || null)
          });
          coupStarter.push(pCoupledStarter);
          const pCoupledBackup = (this.compare && backup) ? ds.getCoupledAttemptProb({
            env, distance:d, score_bin:s, time_bin:t, ytg_bin:y, kickerId:backup.id,
            temp_F: st.tempF||60,
            wind_mph: mph, wind_head_mps: head*0.44704, wind_cross_mps: cross*0.44704,
            altitude_m,
            stadiumId: (st.stadiumId || null)
          }) : null;
          if(this.compare) coupBackup.push(pCoupledBackup);
          x.push(d);
        }
        return {x, base, coupStarter, coupBackup, starter, backup};
      }
  
      _drawAxes(ctx,W,H,pad){
        ctx.clearRect(0,0,W,H); ctx.save(); ctx.translate(pad.l,pad.t); const w=W-pad.l-pad.r, h=H-pad.t-pad.b;
        ctx.strokeStyle='#e5e7eb'; ctx.lineWidth=1; ctx.beginPath();
        for(let gy=0; gy<=10; gy++){ const y=h-h*(gy/10); ctx.moveTo(0,y); ctx.lineTo(w,y); }
        for(let gx=0; gx<=5; gx++){ const x=w*(gx/5); ctx.moveTo(x,0); ctx.lineTo(x,h); }
        ctx.stroke();
        // labels
        ctx.fillStyle='#334155'; ctx.font='12px ui-sans-serif,system-ui'; ctx.textAlign='right';
        for(let gy=0; gy<=10; gy+=2){ const v=gy*10; const y=h-h*(gy/10); ctx.fillText(v+'%', -6, y+4); }
        ctx.textAlign='center'; for(let d=20; d<=68; d+=8){ const x=w*((d-DMIN)/(DMAX-DMIN)); ctx.fillText(d+'y', x, h+18); }
        ctx.restore();
      }
  
      _drawSeries(ctx,W,H,pad,series){
        ctx.save(); ctx.translate(pad.l,pad.t); const w=W-pad.l-pad.r, h=H-pad.t-pad.b;
        const x = (d)=> w*((d-DMIN)/(DMAX-DMIN)); const y = (p)=> h*(1-p);
        this._scales = { x, y, xi:(px)=> (px - pad.l)/(W-pad.l-pad.r)*(DMAX-DMIN)+DMIN };
  
        // curves
        function line(color, arr){ ctx.strokeStyle=color; ctx.lineWidth=2.25; ctx.beginPath(); for(let d=DMIN; d<=DMAX; d++){ const i=d-DMIN; const px=x(d), py=y(arr[i]); if(d===DMIN) ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.stroke(); }
        // Base attempt
        line('#6366f1', series.base); // indigo-500
        // Starter-coupled
        line('#10b981', series.coupStarter); // emerald-500
        // Backup (optional)
        if(this.compare && series.coupBackup?.length){ line('#f43f5e', series.coupBackup.map(v=>v==null? series.base[0]: v)); }
  
        // Legend
        ctx.fillStyle='#0f172a'; ctx.font='12px ui-sans-serif,system-ui';
        function sw(x0,y0,color,label){ ctx.fillStyle=color; ctx.fillRect(x0,y0,14,3); ctx.fillStyle='#0f172a'; ctx.fillText(label, x0+20, y0+4); }
        sw(8, 10, '#6366f1', 'Base Attempt%');
        const stName = series.starter? (series.starter.name||'Starter') : 'Kicker';
        sw(8, 28, '#10b981', `${stName} (coupled)`);
        if(this.compare && series.backup) sw(8, 46, '#f43f5e', `${series.backup.name||'Backup'} (coupled)`);
  
  
        ctx.restore();
      }
  
      _updateInfo(series){
        const ds = this.ds, st = this.state;
        if(!ds || !st){ this.info.textContent = ''; return; }

        const { A, B, C } = ds._sens || { A:0, B:0, C:1 };
        const d = Math.round(st.distance || 45);
        const env = st.env || 'indoor';

        // Use exact-context override (same rules as the chart series)
        function binsFromExact(score, sec, ytg){
          const s = (score <= -3) ? 'trail' : (score >= 3 ? 'lead' : 'close');
          const t = (sec   <= 240) ? 'late'  : (sec   <= 660 ? 'mid'  : 'early');
          const y = (ytg   <= 3)   ? 'short' : (ytg   <= 6   ? 'med'  : 'long');
          return { s, t, y };
        }
        const { s, t, y } = binsFromExact(st.scoreDiffExact ?? 0, st.timeRemSec ?? 900, st.ytgExact ?? 5);

        // Wind components (head/cross in m/s) + altitude
        const mph = Number(st.wind || 0);
        const mps = mph * 0.44704;
        let wind_head_mps = 0, wind_cross_mps = 0;
        const _dir = window.FG?.norm?.windDir(st.windDir) || 'calm';
        switch(_dir){
          case 'head':   wind_head_mps  = +mps; break;
          case 'tail':   wind_head_mps  = -mps; break;
          case 'crossL': wind_cross_mps = -mps; break;
          case 'crossR': wind_cross_mps = +mps; break;
          default: /* calm */ break;
        }
        const altitude_m = Number(st.altitude_m || 0) || 0;

        // Base Attempt and League Make at this point (make uses wind/altitude)
        const pA = ds.getAttemptProb({ env, distance:d, score_bin:s, time_bin:t, ytg_bin:y });
        const pL = ds.getMakeProb({
          env, distance:d,
          temp_F: st.tempF || 60,
          wind_mph: st.wind || 0,
          wind_head_mps, wind_cross_mps, altitude_m,
          stadiumId: (st.stadiumId || null)
        });

        // Starter/backup resolution
        const { starter, backup } = this._findStarterAndBackup();
        const stLabel = starter ? (starter.name || 'Starter') : 'Kicker';
        const currKickerId = this.state?.kicker || starter?.id || null;

        // Row builder (use DataStore’s coupled attempt so it matches the chart logic incl. shrink + wind/alt)
        const rowFor = (id, label) => {
          const pC = ds.getCoupledAttemptProb({
            env, distance:d, score_bin:s, time_bin:t, ytg_bin:y,
            kickerId: id,
            temp_F: st.tempF || 60,
            wind_mph: st.wind || 0,
            wind_head_mps, wind_cross_mps, altitude_m,
            stadiumId: (st.stadiumId || null)
          });
          const sens = pC * (1 - pC) * B;         // d Attempt / d (delta_make_logit)
          const pp10 = sens * 0.1 * 100;          // per +0.1 logit, in percentage points
          return `<tr>
            <td class="px-2 py-1 text-ink-700">${label}</td>
            <td class="px-2 py-1">${(pA*100).toFixed(1)}%</td>
            <td class="px-2 py-1">${(pC*100).toFixed(1)}%</td>
            <td class="px-2 py-1">${pp10.toFixed(2)} pp / +0.1 logit</td>
          </tr>`;
        };

        const aRow = `<div class="pill">A=${A.toFixed(3)}</div><div class="pill">B=${B.toFixed(3)}</div><div class="pill">C=${C.toFixed(3)}</div>`;
        const hdr  = `<table class="mt-2 border border-ink-200 rounded-lg overflow-hidden text-xs">
          <thead class="bg-ink-50 text-ink-600">
            <tr><th class="px-2 py-1 text-left">At ${d}y</th><th class="px-2 py-1 text-left">Base</th><th class="px-2 py-1 text-left">Coupled</th><th class="px-2 py-1 text-left">Sensitivity</th></tr>
          </thead><tbody>`;

        let body = rowFor(currKickerId, stLabel);
        if(this.compare && backup){ body += rowFor(backup.id, backup.name || 'Backup'); }

        this.info.innerHTML = `${aRow}${hdr}${body}</tbody></table>`;
      }

  
      onHover(evt){
        const rect = this.canvas.getBoundingClientRect(); const x = evt.clientX - rect.left; const y = evt.clientY - rect.top;
        const st = this._scales; if(!st) return; const dApprox = Math.round(st.xi(x)); const d=Math.min(DMAX, Math.max(DMIN, dApprox));
        const i=d-DMIN; const s=this._series; if(!s) return;
        const pB=s.base[i]; const pS=s.coupStarter[i]; const pBk = (this.compare && s.coupBackup?.length)? s.coupBackup[i] : null;
        const html = `<div><b>${d} yards</b></div>
                      <div>Base: ${(pB*100).toFixed(1)}%</div>
                      <div>${(s.starter?.name||'Kicker')}: ${(pS*100).toFixed(1)}%</div>
                      ${pBk!=null? `<div>${(s.backup?.name||'Backup')}: ${(pBk*100).toFixed(1)}%</div>`: ''}`;
        this.tooltip.show(evt.clientX, evt.clientY, html);
        this._drawHover(d);
      }
  
      _drawHover(d){
        const W=this.overlay.width/(window.devicePixelRatio||1), H=this.overlay.height/(window.devicePixelRatio||1);
        const pad={l:48,t:16,r:16,b:28}; const w=W-pad.l-pad.r, h=H-pad.t-pad.b;
        const x = (dd)=> w*((dd-DMIN)/(DMAX-DMIN));
        const y = (p)=> h*(1-p);
        const i=d-DMIN; const s=this._series; if(!s) return;
        this.octx.setTransform(1,0,0,1,0,0); this.octx.clearRect(0,0,W,H); this.octx.setTransform(window.devicePixelRatio||1,0,0,window.devicePixelRatio||1,0,0);
        this.octx.translate(pad.l,pad.t); this.octx.strokeStyle='rgba(15,23,42,.25)'; this.octx.beginPath(); this.octx.moveTo(x(d),0); this.octx.lineTo(x(d),h); this.octx.stroke();
        // markers
        this.octx.fillStyle='#6366f1'; this.octx.beginPath(); this.octx.arc(x(d), y(s.base[i]), 3.5, 0, Math.PI*2); this.octx.fill();
        this.octx.fillStyle='#10b981'; this.octx.beginPath(); this.octx.arc(x(d), y(s.coupStarter[i]), 3.5, 0, Math.PI*2); this.octx.fill();
        if(this.compare && s.coupBackup?.length){ this.octx.fillStyle='#f43f5e'; this.octx.beginPath(); this.octx.arc(x(d), y(s.coupBackup[i]), 3.5, 0, Math.PI*2); this.octx.fill(); }
      }
  
      render(){
        if(!this.root||!this.ctx) return;
        if(!this.ds||!this.state){ const ctx=this.ctx, W=this.canvas.width/(window.devicePixelRatio||1), H=this.canvas.height/(window.devicePixelRatio||1); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,W,H); ctx.font='12px ui-sans-serif,system-ui'; ctx.fillStyle='#64748b'; ctx.fillText('Loading data…', 12, 18); return; }
        this._series = this._calcSeries(); if(!this._series) return;
        const W=this.canvas.width/(window.devicePixelRatio||1), H=this.canvas.height/(window.devicePixelRatio||1); const pad={l:48,t:16,r:16,b:28};
        this._drawAxes(this.ctx,W,H,pad); this._drawSeries(this.ctx,W,H,pad,this._series); this.octx.clearRect(0,0,this.overlay.width,this.overlay.height);
        this._updateInfo(this._series);
      }
    }
  
    async function mount(){
      const el = document.getElementById('attemptTab'); 
      if(!el || !window.FG?.mountOnce?.(el, 'attemptTab')) return; // guard
      const chart = new AttemptChart(el);
      const ds = await window.FG?.ready?.();
      await chart.setDataStore(ds);
      chart.setState(window.state||{});
      window.FG?.on(window, 'fg:stateChanged', (e)=> chart.setState(e.detail||window.state||{}), 'attempt:state');
    }
    if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', mount, { once:true }); else mount();

  })();
  </script>
  
  <!-- =========================
FG Pro UI v4 — Part 6/6 (Decision Edge + Export)
Paste this <script> block near the end of index.html AFTER Parts 1–5.
- Computes EP/WP edges for FG vs Go vs Punt
- Prefers optional wp_edges.json (WP with CI); otherwise uses EP proxy
- One-click "Copy snapshot" export of current inputs/outputs
- About panel shows model/data versions from manifest (Part 2)
========================= -->
<script>
  (function(){
    const PX = (v)=>Math.max(0, Math.round(v));
  
    function logit(p){ p=Math.min(Math.max(+p,1e-9),1-1e-9); return Math.log(p/(1-p)); }
    function sigmoid(x){ return 1/(1+Math.exp(-x)); }
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  
    // ---------- optional WP edges loader ----------
    let WPIndex = null; // Map keyed by env|d|s|t|y
    async function loadWPEdges(){
      try{
        const res = await fetch('./wp_edges.json', { cache: 'no-store' });
        if(!res.ok) return null; const obj = await res.json();
        const grid = Array.isArray(obj?.grid) ? obj.grid : [];
        const map = new Map();
        for(const r of grid){
          const key = [r.env || r.indoor_outdoor || 'indoor', Math.round(+r.distance||0), r.score_bin||'close', r.time_bin||'mid', r.ytg_bin||'med'].join('|');
          map.set(key, r);
        }
        WPIndex = map; return map;
      }catch{ return null; }
    }
  
    function lookupWP(env, d, s, t, y){
      if(!WPIndex) return null; const key=[env,Math.round(d),s,t,y].join('|'); return WPIndex.get(key)||null;
    }
  
    // ---------- EP proxy (when no WP edges file) ----------
    function ep_go_from_yardline(y100){
      // Rough 1st&10 EP at opponent yardline (y100 ∈ [1,51])
      // Linear-ish: high near GL, ~2.4 at 40, ~2.0 at 50
      const ep = 6.2 - 0.075*y100; // 6.2 @1, ~2.4@50
      return clamp(ep, 1.5, 6.0);
    }
    function ep_punt_from_yardline(y100){
      // Approx EP cost of punting from opponent territory.
      // ~-0.6 near opp40, ~-0.4 near opp50, ~-1.0 near opp20
      const base = 0.6 + 0.02*(40 - y100);
      return -clamp(base, 0.2, 1.2);
    }

    function windParts(st){
    const mph = +st.wind || 0;
    const dir = st.windDir || 'calm';
    let head=0, cross=0;
    if(dir==='head') head =  mph;
    else if(dir==='tail') head = -mph;
    else if(dir==='crossL' || dir==='crossR') cross = mph;
    return { wind_mph: mph, wind_head_mps: head*0.44704, wind_cross_mps: cross*0.44704 };
  }

  
    function computeEdges(ds, st){
      const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
      const env = st.env || 'indoor';
      const d   = clamp(Math.round(st.distance||45), 18, 68);
      const yard100 = clamp(d - 17, 1, 99);

      // Exacts
      const down = clamp(+st.down||4, 1, 4);
      const ytg  = clamp(+st.ytgExact||5, 0, 40);
      const sec  = clamp(+st.timeRemSec||900, 0, 1800);
      const sd   = (+st.scoreDiffExact)||0;
      const toO  = clamp(+st.toOff||3, 0, 3);
      const toD  = clamp(+st.toDef||3, 0, 3);

      const { wind_mph, wind_head_mps, wind_cross_mps } = windParts(st);
      const altitude_m = (st.altitude_m != null) ? st.altitude_m
                        : (st.alt==='high' ? 1600 : st.alt==='mid' ? 500 : 0);

      // League & kicker make
      const pL = ds.getMakeProb({
        env, distance:d, temp_F: st.tempF||60,
        wind_mph, wind_head_mps, wind_cross_mps,
        altitude_m,
        stadiumId: (st.stadiumId || null)
      });
      const del = ds.getKickerDeltaLogit(st.kicker||null, d) || {delta_logit:0, se:0};
      const w = 1 / (1 + Math.pow((+del.se||0)/0.8, 2));
      const pK = sigmoid(logit(pL) + (+del.delta_logit||0)*w);


      // Try WP file by nearest bins (fallback if not present)
      const s = (sd<=-3)?'trail':(sd>=3?'lead':'close');
      const t = (sec<=240)?'late':(sec<=660?'mid':'early');
      const y = (ytg<=3)?'short':(ytg<=6?'med':'long');
      const wp = (typeof lookupWP==='function') ? lookupWP(env, d, s, t, y) : null;
      if (wp){
        return {
          metric:'WP', unit:'pp',
          p_league:pL, p_kicker:pK,
          actions:{
            FG_vs_Go:   { mean: wp.edge_fg_go_mean ?? null,   ci: (wp.edge_fg_go_p10!=null&&wp.edge_fg_go_p90!=null)?{lo:wp.edge_fg_go_p10,hi:wp.edge_fg_go_p90}:null },
            FG_vs_Punt: { mean: wp.edge_fg_punt_mean ?? null, ci: (wp.edge_fg_punt_p10!=null&&wp.edge_fg_punt_p90!=null)?{lo:wp.edge_fg_punt_p10,hi:wp.edge_fg_punt_p90}:null }
          }
        };
      }

      // EP proxy (distance-aware + exacts)
      const EP_kick = 3 * pK;
      let EP_go = 6.0 - 0.08*yard100;         // base by yardline
      EP_go -= 0.15*Math.max(0, ytg-3);       // harder with long YTG
      EP_go -= (down>=3 ? 0.35 : 0);
      EP_go -= (down===4 ? 0.60 : 0);
      EP_go += 0.05*Math.max(0, 3 - toO);     // fewer TOs hurts
      EP_go += (sec<=120 ? -0.40 : 0);        // end-of-half
      EP_go += (sd>=7 ? -0.10 : (sd<=-7 ? 0.10 : 0));
      EP_go = Math.max(0.5, Math.min(6.5, EP_go));

      let EP_punt = -0.2 - 0.015*(50 - yard100); // opp-territory punts worse
      EP_punt += (sec<=180 ? -0.25 : 0);
      EP_punt = Math.max(-1.25, Math.min(0.2, EP_punt));

      return {
        metric:'EP', unit:'pts',
        p_league:pL, p_kicker:pK,
        actions:{
          FG_vs_Go:   { mean: (EP_kick - EP_go),   ci: null },
          FG_vs_Punt: { mean: (EP_kick - EP_punt), ci: null }
        },
        ep_breakdown:{ EP_kick, EP_go, EP_punt, yardline_100:yard100, down, ytg, sec, sd, toO, toD }
      };
    }

  
    // ---------- UI rendering ----------
    function ensurePanel(){
      const tab = document.getElementById('decisionTab') || document.getElementById('edgePanel') || document.getElementById('decisionPanel');
      if(!tab) return null;

      let card = document.getElementById('fgEdgeCard');
      if(!card){
        // single, full-width card
        tab.innerHTML = '';
        card = document.createElement('section');
        card.id = 'fgEdgeCard';
        card.className = 'card card-pad';
        tab.appendChild(card);
      }
      return { card };
    }
  
    function fmt(x, unit){
      if(x==null || !isFinite(x)) return '—';
      if(unit==='pp') return (x*100).toFixed(1)+' pp';
      if(unit==='pts') return x.toFixed(2)+' pts';
      return String(x);
    }
  
    function barHTML(val, unit){
      // simple diverging bar (- to +)
      const v = Math.max(-3, Math.min(3, (unit==='pp'? val*100 : val))); // normalize roughly
      const pct = Math.abs(v)/3*100; const dir = v>=0 ? 'to right' : 'to left';
      const color = v>=0 ? 'rgba(16,185,129,.9)' : 'rgba(244,63,94,.9)';
      const grad = `linear-gradient(${dir}, ${color} ${pct}%, rgba(0,0,0,0) ${pct}%)`;
      return `<div class="h-2 rounded bg-ink-100 overflow-hidden" title="${fmt(val, unit)}"><div class="h-2" style="width:100%; background:${grad}"></div></div>`;
    }
  
    function renderEdges(card, ds, st, res){
      const m = res.metric; const unit = res.unit;
      const pL = res.p_league, pK = res.p_kicker; const d = Math.round(st.distance||45);
  
      const rows = [];
      function addRow(label, v, ci){
        const ciHTML = ci? `<div class="text-[11px] text-ink-500">80% CI: ${fmt(ci.lo, unit)} to ${fmt(ci.hi, unit)}</div>` : '';
        rows.push(`<tr>
          <td class="px-2 py-2 text-ink-700">${label}</td>
          <td class="px-2 py-2 whitespace-nowrap">${fmt(v, unit)}</td>
          <td class="px-2 py-2 w-48">${barHTML(v, unit)}${ciHTML}</td>
        </tr>`);
      }
  
      addRow('FG vs Go',   res.actions.FG_vs_Go.mean,   res.actions.FG_vs_Go.ci);
      addRow('FG vs Punt', res.actions.FG_vs_Punt.mean, res.actions.FG_vs_Punt.ci);
  
      const ctxLabel = `${st.scoreBin||'close'} • ${st.timeBin||'mid'} • ${st.ytgBin||'med'} • ${st.env||'indoor'}`;
      const header = `<div class="flex items-center justify-between mb-3">
        <div>
          <div class="text-sm font-semibold">Decision Edge (${m})</div>
          <div class="text-[12px] text-ink-500">At ${d} yards • ${ctxLabel}</div>
        </div>
        <div class="flex gap-2 items-center">
          <div class="pill">League Make: ${(pL*100).toFixed(1)}%</div>
          <div class="pill">Kicker: ${(pK*100).toFixed(1)}%</div>
          <button id="copySnapshotBtn" class="btn">Copy snapshot</button>
        </div>
      </div>`;
  
      let epDetail = '';
      if(res.metric==='EP' && res.ep_breakdown){
        const b = res.ep_breakdown;
        epDetail = `<div class="mt-2 grid grid-cols-3 gap-3 text-xs">
          <div class="rounded border border-ink-200 p-2"><div class="text-ink-500">EP(FG)</div><div class="text-ink-800 text-sm">${b.EP_kick.toFixed(2)}</div></div>
          <div class="rounded border border-ink-200 p-2"><div class="text-ink-500">EP(Go)</div><div class="text-ink-800 text-sm">${b.EP_go.toFixed(2)}</div></div>
          <div class="rounded border border-ink-200 p-2"><div class="text-ink-500">EP(Punt)</div><div class="text-ink-800 text-sm">${b.EP_punt.toFixed(2)}</div></div>
        </div>`;
      }
  
      card.innerHTML = header +
        `<table class="w-full text-sm border border-ink-200 rounded-lg overflow-hidden"><thead class="bg-ink-50 text-ink-600"><tr>
          <th class="px-2 py-2 text-left">Comparison</th>
          <th class="px-2 py-2 text-left">Edge</th>
          <th class="px-2 py-2 text-left">Impact</th>
        </tr></thead><tbody>${rows.join('')}</tbody></table>` + epDetail;
  
      // Bind copy
      const btn = document.getElementById('copySnapshotBtn');
      btn?.addEventListener('click', ()=> copySnapshot(ds, st, res));
    }
  
    function renderAbout(aboutEl, ds){
      const versions = ds?.getVersions?.() || { data:'local', schema:'v1' };
      const mf = ds?._manifest || {};
      const hashes = mf.model_hashes || {};
      const items = Object.keys(hashes).map(k=>`<div class="flex justify-between"><span class="text-ink-500">${k}</span><span class="font-mono">${String(hashes[k]).slice(0,12)}</span></div>`).join('') || '<div class="text-ink-500">—</div>';
      const when = mf.generated_at_epoch ? new Date(mf.generated_at_epoch*1000).toLocaleString() : 'local';
      const files = ds?.files || {};
      const present = Object.entries(files).filter(([name,url])=> name!=='manifest').map(([name,url])=>`<span class="pill">${name}${(ds && !String(ds[name]) && !url)?' (—)':''}</span>`).join(' ');
  
      aboutEl.innerHTML = `<div class="text-sm font-semibold mb-2">About this model</div>
        <div class="text-xs text-ink-600">Data version: <span class="text-ink-800">${versions.data}</span> • Schema: <span class="text-ink-800">${versions.schema}</span></div>
        <div class="text-xs text-ink-600 mt-2">Generated: <span class="text-ink-800">${when}</span></div>
        <div class="text-xs text-ink-600 mt-2">Model hashes</div>
        <div class="mt-1 text-xs space-y-1">${items}</div>
        <div class="text-xs text-ink-600 mt-2">Loaded files</div>
        <div class="mt-1 flex flex-wrap gap-1">${present}</div>`;
    }
  
    async function copySnapshot(ds, st, res){
      const payload = {
        ts_iso: new Date().toISOString(),
        team: st.team||null,
        kicker: st.kicker||null,
        stadiumId: st.stadiumId || null,
        env: st.env||'indoor',
        distance: Math.round(st.distance||45),
        temp_F: st.tempF||60,
        wind_mph: st.wind||0,
        score_bin: st.scoreBin||'close', time_bin: st.timeBin||'mid', ytg_bin: st.ytgBin||'med',
        make_league: res.p_league, make_kicker: res.p_kicker,
        edges: res.actions,
        metric: res.metric, unit: res.unit,
        about: ds?._manifest ? { generated_at_epoch: ds._manifest.generated_at_epoch||null, model_hashes: ds._manifest.model_hashes||null } : null
      };
      try{
        await navigator.clipboard.writeText(JSON.stringify(payload, null, 2));
        window.FG?.toast?.('Snapshot copied to clipboard.', 'info', 2200);
      }catch{
        // fallback: offer a download
        const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'fg_snapshot.json'; a.click(); URL.revokeObjectURL(a.href);
        window.FG?.toast?.('Snapshot downloaded.', 'info', 2200);
      }
    }
  
    // ---------- Mount ----------
    async function mount(){
      const ds = window.FG?.DataStore || await window.FG?.DataStoreClass?.init?.({ baseUrl: '.' });
      try { await loadWPEdges(); } catch {}

      const panels = ensurePanel();
      if(!panels) return;

      // Remove the About card (or hide it) so it doesn't sit near the top
      if (panels.about) { panels.about.remove(); }
      // And don't call renderAbout anymore

      (function activateDecisionTab(){
        const btns = [...document.querySelectorAll('.tab-btn')];
        const panelEls = {
          makeTab: document.getElementById('makeTab'),
          attemptTab: document.getElementById('attemptTab'),
          decisionTab: document.getElementById('decisionTab')
        };
        btns.forEach(btn=> btn.setAttribute('aria-selected', String(btn.dataset.tab === 'decisionTab')));
        Object.entries(panelEls).forEach(([id, el])=> el && el.classList.toggle('hidden', id !== 'decisionTab'));
      })();

      function deriveWindComponents(st){
        const mph = Number(st.wind || 0);
        const mps = mph * 0.44704;
        let head = 0, cross = 0;
        switch(String(st.windDir||'calm')){
          case 'head':   head  = +mps; break;
          case 'tail':   head  = -mps; break;
          case 'crossL': cross = -mps; break;
          case 'crossR': cross = +mps; break;
        }
        return { wind_head_mps: head, wind_cross_mps: cross };
      }

      let rafId = null;
      const renderAll = ()=>{
        if(rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(()=>{
          const st    = window.state || {};
          const windV = deriveWindComponents(st);
          const stAug = { ...st, ...windV };
          const res = computeEdges(ds, stAug);
          renderEdges(panels.card, ds, stAug, res);
          // renderAbout(panels.about, ds); // <-- removed
        });
      };

      renderAll();
      window.addEventListener('fg:stateChanged', renderAll);
    }


if(document.readyState === 'loading'){
  document.addEventListener('DOMContentLoaded', mount);
}else{
  mount();
}

  })();
  </script>
  
  <script id="fg-bootstrap-selectors-stadiums">
    (function(){
      // --------- tiny fetch + CSV helpers ----------
      async function textFetch(url){
        try{ const r = await fetch(url + '?v=' + Date.now()); if(!r.ok) return null; return await r.text(); }
        catch{ return null; }
      }
      function parseCSVRow(line){
        let out=[],cur='',q=false;
        for(let i=0;i<line.length;i++){
          const c=line[i];
          if(q){
            if(c=='"'){ if(line[i+1]=='"'){cur+='"'; i++;} else {q=false;} }
            else cur+=c;
          }else{
            if(c=='"'){ q=true; }
            else if(c==','){ out.push(cur); cur=''; }
            else cur+=c;
          }
        }
        out.push(cur);
        return out.map(s=>s.trim());
      }
      function parseCSV(txt){
        if(!txt) return [];
        const lines=txt.replace(/\r/g,'').split('\n').filter(l=>l.trim());
        if(!lines.length) return [];
        const head=parseCSVRow(lines.shift());
        return lines.map(l=>{ const c=parseCSVRow(l), o={}; head.forEach((h,i)=> o[h]=c[i]??''); return o; });
      }
  
      const ds = window.FG?.DataStore || {};
  
      // --------- Roster getters (fallback if DataStore didn’t set them) ----------
      async function ensureRosterGetters(){
        if (ds.getTeams && ds.getKickersByTeam && ds.getStarterForTeam) {
          try { if ((ds.getTeams()||[]).length) return; } catch {}
        }
        let roster = ds.roster || null;
        if (!roster) { try{ roster = await fetch('./nfl_kicker_roster.json?v='+Date.now()).then(r=>r.json()); }catch{} }
        if (!Array.isArray(roster)) { console.warn('Roster JSON missing'); return; }
  
        const byTeam = new Map();
        for (const r of roster){
          const RAW = (r.team||r.posteam||r.team_abbr||r.Team||r.club_code||'').toUpperCase();
          const ALIAS = {
            ARZ:'ARI', JAC:'JAX', LA:'LAR', SD:'LAC', STL:'LAR', OAK:'LV',
            WSH:'WAS', WAS:'WAS', TB:'TB', SF:'SF', NE:'NE', NO:'NO'
          };
          const t = ALIAS[RAW] || RAW;
          if(!t) continue;
          const name = r.kicker_name || r.player_name || r.player || r.name || r.full_name || r.Player || '';
          const kid  = String(r.kicker_id || r.player_id || r.gsis_id || r.id || name).trim();
          const status = String(r.status||r.note||r.availability||'active');
          const depth = String(r.depth||r.pos_rank||r.depth_chart||r.depth_order||r.dc_rank||r.depth_chart_order||r.role||'');
          const isStarter = /(^1$|\bK1\b|starter|primary)/i.test(depth) || String(r.is_starter).toLowerCase()==='true';
          const active = !/(inactive|injured|ir|retired|practice)/i.test(status);
          const _pos = String(r.pos_abb||r.depth_position||r.position||r.pos_name||'').toUpperCase();
          const _dc  = String(r.depth_chart||'').toUpperCase();
          const isPK = _pos==='PK' || /^K\d$/.test(_dc) || /PLACE\s*KICK/i.test(String(r.pos_name||''));
          if(!isPK) continue;
          const row = { id:kid, name, active, isStarter };
          if(!byTeam.has(t)) byTeam.set(t, []);
          byTeam.get(t).push(row);
        }
  
        ds.getTeams = ()=> Array.from(byTeam.keys()).sort();
        ds.getKickersByTeam = (team)=> (byTeam.get((team||'').toUpperCase()) || [])
            .sort((a,b)=> (b.isStarter - a.isStarter) || a.name.localeCompare(b.name));
        ds.getStarterForTeam = (team)=> (ds.getKickersByTeam(team)[0] || null);
  
        window.FG.DataStore = Object.assign(window.FG.DataStore||{}, ds);
      }
  
      // --------- Stadiums (from ./team_stadiums.csv) ----------
      async function ensureStadiums(){
        // Already wired?
        if (ds.getStadiums && ds.getAllStadiums && ds.getVenueById && ds.inferVenue) return;
  
        let rows=[]; const txt = await textFetch('./team_stadiums.csv');
        if(txt) rows = parseCSV(txt);
  
        // Normalize + index
        const byTeam = new Map();
        const byId   = new Map();
        const all    = [];
  
        function normRow(r){
          const team = String(r.team||r.team_fastr||'').toUpperCase();
          const name = r.stadium_name || r.stadium || r.venue || '';
          const id   = (r.stadium_id || r.stadium || r.venue || name || '').toString();
          const roof = String(r.roof_type||r.roof||'').toLowerCase();
          const env  = (roof.includes('dome') || roof.includes('retract')) ? 'indoor' : 'outdoor';
          const altm = Number(r.altitude_m || r.altitude || 0) || 0;
          const is_current = String(r.is_current||'').toLowerCase()==='true';
          return { id, team, name, roof_type: roof, env, altitude_m: altm, is_current, _raw:r };
        }
  
        for(const r of rows){
          const v = normRow(r);
          if(!v.id || !v.name) continue;
  
          // byTeam
          if(v.team){
            if(!byTeam.has(v.team)) byTeam.set(v.team, []);
            byTeam.get(v.team).push(v);
          }
          // Dedup for "all"
          if(!byId.has(v.id)){ byId.set(v.id, v); all.push(v); }
        }
  
        // API
        ds.getStadiums = function(team){
          const T=(team||'').toUpperCase();
          return (byTeam.get(T)||[]).slice().sort((a,b)=> (b.is_current - a.is_current) || a.name.localeCompare(b.name));
        };
        ds.getAllStadiums = function(){
          return all.slice().sort((a,b)=> a.name.localeCompare(b.name));
        };
        ds.getVenueById = function(id){
          return byId.get(String(id)) || null;
        };
        ds.inferVenue = function(team){
          const list = ds.getStadiums(team); if(!list.length) return null;
          const cur = list.find(s => s.is_current) || list[0];
          return { id: cur.id, name: cur.name, env: cur.env, altitude_m: cur.altitude_m, raw: cur._raw };
        };
  
        window.FG.DataStore = Object.assign(window.FG.DataStore||{}, ds);
      }
  
      // --------- UI helpers ----------
      function option(label, value, extra = {}){
  const o = document.createElement('option');
  o.textContent = label ?? '';
  o.value = value ?? '';
  if (extra.disabled) o.disabled = true;
  if (extra.selected) o.selected = true;
  return o;
}

function emit(){
  window.dispatchEvent(
    new CustomEvent('fg:stateChanged', { detail: { ...(window.state || {}) } })
  );
}

function feet(m){ return Math.round((Number(m) || 0) * 3.28084); }

function altitudeBin(m){
  const ft = feet(m);
  if (ft >= 4000) return 'high';
  if (ft >= 1000) return 'mid';
  return 'sea';
}

function annotateAltitudeSeg(){
  const seg = document.querySelector('[aria-label="Altitude"]');
  if (!seg) return;

  const RANGE_HINT = {
    sea: '0–999 ft',
    mid: '1,000–3,999 ft',
    high: '4,000+ ft'
  };

  [...seg.querySelectorAll('button[data-alt]')].forEach(btn => {
    if (btn.dataset.hinted === '1') return; // only once
    const label = (btn.textContent || '').trim();

    // Add a tiny range hint under the label (inline styles so it works without JIT)
    const hint = RANGE_HINT[btn.dataset.alt] || '';
    btn.innerHTML =
      `${label}<span style="display:block;font-size:10px;line-height:1;opacity:.65;margin-top:2px">${hint}</span>`;
    btn.dataset.hinted = '1';
  });
}

function reflectAltitudeSeg(meters){
  const seg = document.querySelector('[aria-label="Altitude"]');
  if (!seg) return;

  const bin = altitudeBin(meters);
  const ft  = feet(meters).toLocaleString();

  [...seg.querySelectorAll('button[data-alt]')].forEach(btn => {
    const on = btn.dataset.alt === bin;
    btn.classList.toggle('on', on);
    btn.classList.toggle('off', !on);
    btn.setAttribute('aria-pressed', String(on));
  });

  // Put the exact feet as a tooltip on the selected button (non-intrusive detail)
  const selected = seg.querySelector(`button[data-alt="${bin}"]`);
  if (selected) selected.title = `${ft} ft`;
}

  
      // --------- Fillers ----------
      function fillTeams(){
        const el=document.getElementById('teamSelect'); 
        const elLR=document.getElementById('teamSelectLR');
        if(!ds.getTeams) return;
        const teams = ds.getTeams();
        if(el){ el.innerHTML=''; el.appendChild(option('— select —','')); teams.forEach(t=> el.appendChild(option(t,t))); }
        if(elLR){ elLR.innerHTML=''; elLR.appendChild(option('— select —','')); teams.forEach(t=> elLR.appendChild(option(t,t))); }
      }
  
      function fillKickers(team){
        const top  = document.getElementById('kickerSelect');
        const left = document.getElementById('kickerSelectLR');

        // If no team or no DS API, disable both selects gracefully
        const noTeamOrAPI = !team || !(ds?.getKickersByTeam || ds?.getKickers);
        if (noTeamOrAPI){
          [top, left].forEach(el=>{
            if(!el) return;
            el.innerHTML = '';
            el.appendChild(option('— select team first —',''));
            el.disabled = true;
          });
          return '';
        }

        // Fetch list (prefer getKickersByTeam)
        const list = (ds.getKickersByTeam ? ds.getKickersByTeam(team) : ds.getKickers(team)) || [];

        // Helpers
        const isStarter = k => !!(k.isStarter || k.starter);
        const isActive  = k => (k.active !== false) && !/inactive|ir|retired/i.test(String(k.status||''));
        const prevId    = window.state?.kicker ? String(window.state.kicker) : '';

        // Apply options into a given <select>
        function apply(el){
          if(!el) return;
          el.innerHTML = '';
          if(!list.length){
            el.appendChild(option('— no kickers —',''));
            el.disabled = true;
            return;
          }
          el.disabled = false;
          for(const k of list){
            const label = `${k.name || k.full_name || 'Kicker'}${isStarter(k) ? ' (starter)' : ''}${isActive(k) ? '' : ' [inactive]'}`;
            el.appendChild(option(label, String(k.id), { disabled: !isActive(k) }));
          }
        }

        apply(top);
        apply(left);

        // Choose a coherent selected value across both selects:
        // 1) keep previous selection if still available & active
        // 2) else pick starter, else first active, else first
        const hasPrev     = prevId && list.some(k => String(k.id) === prevId && isActive(k));
        const starter     = list.find(isStarter);
        const firstActive = list.find(isActive) || list[0];
        const selectedId  = hasPrev ? prevId : String((starter?.id ?? firstActive?.id ?? ''));

        if (top)  top.value  = selectedId;
        if (left) left.value = selectedId;

        // Return the selected id (caller may choose to put it into state & emit)
        return selectedId;
      }

  
      function fillStadiums(team){
        const el=document.getElementById('stadiumSelectLR');
        if(!el || !ds.getStadiums || !ds.getAllStadiums) return;
  
        const teamVenues = ds.getStadiums(team);
        const allVenues  = ds.getAllStadiums();
  
        el.innerHTML='';
        el.appendChild(option('— select venue —',''));
  
        // Optgroup: Team venues
        if(teamVenues.length){
          const og1 = document.createElement('optgroup'); og1.label = 'Team venues';
          teamVenues.forEach(v=>{
            const ft = feet(v.altitude_m);
            const lab = `${v.name} • ${v.env} • ${ft} ft`;
            og1.appendChild(option(lab, v.id));
          });
          el.appendChild(og1);
        }
  
        // Optgroup: All venues
        const og2 = document.createElement('optgroup'); og2.label = 'All venues';
        allVenues.forEach(v=>{
          const ft = feet(v.altitude_m);
          const lab = `${v.name} • ${v.env} • ${ft} ft`;
          og2.appendChild(option(lab, v.id));
        });
        el.appendChild(og2);
  
        // Preselect inferred current venue
        const inf = ds.inferVenue?.(team);
        if(inf){ el.value = inf.id; }
        el.disabled = false;
      }
  
      // --------- Bind events (top + left, kept in sync) ----------
      function bindEvents(){
        const teamTop  = document.getElementById('teamSelect');
        const teamLeft = document.getElementById('teamSelectLR');
        const kickTop  = document.getElementById('kickerSelect');
        const kickLeft = document.getElementById('kickerSelectLR');
        const stadSel  = document.getElementById('stadiumSelectLR');
  
        function onTeamChange(newTeam){
          const t = (newTeam||'').toUpperCase();
          window.state = window.state || {};
          window.state.team = t;
  
          // keep team selects in sync
          if(teamTop)  teamTop.value  = t;
          if(teamLeft) teamLeft.value = t;
  
          // refill kickers + stadiums, set defaults
          fillKickers(t);
          const starter = ds.getStarterForTeam?.(t);
          if (starter){
            window.state.kicker = String(starter.id);
            if(kickTop)  kickTop.value  = String(starter.id);
            if(kickLeft) kickLeft.value = String(starter.id);
          }
  
          fillStadiums(t);
          const v = ds.inferVenue?.(t);
          if (v){
            window.state.stadiumId  = v.id;
            window.state.env        = v.env;
            window.state.altitude_m = v.altitude_m || 0;
            if (stadSel) stadSel.value = v.id;
            reflectAltitudeSeg(window.state.altitude_m);
          }
          emit();
        }
  
        function onKickerChange(id){
          window.state = window.state || {};
          window.state.kicker = id || '';
          if(kickTop)  kickTop.value  = id;
          if(kickLeft) kickLeft.value = id;
          emit();
        }
  
        function onStadiumChange(id){
          window.state = window.state || {};
          window.state.stadiumId = id || '';
          const v = ds.getVenueById?.(id);
          if(v){
            const roof=v.roof_type||'';
            window.state.env = (String(roof).includes('dome')||String(roof).includes('retract')) ? 'indoor' : (v.env||'outdoor');
            window.state.altitude_m = Number(v.altitude_m||0) || 0;
            reflectAltitudeSeg(window.state.altitude_m);
          }
          const _in = document.getElementById('envIndoor');
          const _out = document.getElementById('envOutdoor');
          if (_in && _out){
            const e = window.state.env;
            _in.classList.toggle('on',  e==='indoor');
            _in.classList.toggle('off', e!=='indoor');
            _in.setAttribute('aria-pressed', String(e==='indoor'));
            _out.classList.toggle('on',  e==='outdoor');
            _out.classList.toggle('off', e!=='outdoor');
            _out.setAttribute('aria-pressed', String(e==='outdoor'));
          }
          emit();
        }
  
        // team changes (TOP + LEFT)
        teamTop  && teamTop.addEventListener('change',  ()=> onTeamChange(teamTop.value));
        teamLeft && teamLeft.addEventListener('change', ()=> onTeamChange(teamLeft.value));
  
        // kicker changes (TOP + LEFT)
        kickTop  && kickTop.addEventListener('change',  ()=> onKickerChange(kickTop.value));
        kickLeft && kickLeft.addEventListener('change', ()=> onKickerChange(kickLeft.value));
  
        // stadium change (LEFT)
        stadSel && stadSel.addEventListener('change', ()=> onStadiumChange(stadSel.value));
      }
  
      // --------- Init ----------
      async function init(){
        await ensureRosterGetters();
        await ensureStadiums();
        annotateAltitudeSeg();
        fillTeams();
  
        // select first team if none
        const teams = ds.getTeams?.() || [];
        const firstTeam = teams[0] || '';
        if(firstTeam){
          // set both team selects to firstTeam so fill* calls use the same
          const teamTop  = document.getElementById('teamSelect');
          const teamLeft = document.getElementById('teamSelectLR');
          if(teamTop)  teamTop.value  = firstTeam;
          if(teamLeft) teamLeft.value = firstTeam;
          fillKickers(firstTeam);
          fillStadiums(firstTeam);
  
          // seed state from inferred venue
          const v = ds.inferVenue?.(firstTeam);
          window.state = Object.assign({
            team:firstTeam,
            kicker:(ds.getStarterForTeam?.(firstTeam)||{}).id || '',
            stadiumId:v?.id || '',
            env:v?.env || (window.state?.env || 'indoor'),
            altitude_m:v?.altitude_m || 0
          }, window.state||{});
          reflectAltitudeSeg(window.state.altitude_m);
          const _in = document.getElementById('envIndoor');
          const _out = document.getElementById('envOutdoor');
          if (_in && _out){
            const e = window.state.env;
            _in.classList.toggle('on',  e==='indoor');
            _in.classList.toggle('off', e!=='indoor');
            _in.setAttribute('aria-pressed', String(e==='indoor'));
            _out.classList.toggle('on',  e==='outdoor');
            _out.classList.toggle('off', e!=='outdoor');
            _out.setAttribute('aria-pressed', String(e==='outdoor'));
          }
          emit();
        }
  
        bindEvents();
      }
  
      if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', init);
      else init();
    })();
  </script>
  
    

    <script>
      (function(){
        const downSel   = document.getElementById('downSel');
        const ytgExact  = document.getElementById('ytgExact');
        const timeMMSS  = document.getElementById('timeMMSS');
        const scoreEx   = document.getElementById('scoreDiffExact');
        const toOff     = document.getElementById('toOff');
        const toDef     = document.getElementById('toDef');
      
        window.state = Object.assign({
          down:4, ytgExact:5, timeRemSec:450, scoreDiffExact:0, toOff:3, toDef:3
        }, window.state||{});
      
        function parseMMSS(s){
          const m = /^\s*(\d{1,2})\s*:\s*(\d{2})\s*$/.exec(String(s||'')); if(!m) return null;
          return Math.max(0, (+m[1])*60 + (+m[2]));
        }
      
        function sync(){
          const st = window.state;
          st.down = +downSel.value || 4;
          st.ytgExact = Math.max(0, +ytgExact.value||0);
          st.scoreDiffExact = +scoreEx.value || 0;
          st.toOff = Math.max(0, Math.min(3, +toOff.value||0));
          st.toDef = Math.max(0, Math.min(3, +toDef.value||0));
          const secs = parseMMSS(timeMMSS.value); if(secs!=null) st.timeRemSec = secs;
          window.dispatchEvent(new CustomEvent('fg:stateChanged', { detail: {...st} }));
        }
      
        [downSel, ytgExact, timeMMSS, scoreEx, toOff, toDef].forEach(el=> el && el.addEventListener('input', sync));
      })();
      </script>
      

</body>
</html>
